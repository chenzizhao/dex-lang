' ## Monte Carlo Tree Search

def (+!) (n:a) (m:Int) : a = ((ordinal n) + m)@_
def (-!) (n:a) (m:Int) : a = ((ordinal n) - m)@_
def xor (a:Bool) (b:Bool) : Bool = ((not a) && b) || (a && (not b))

' ### Tree types

data Node nodeIx a =
  Branch content:a parent:(Maybe nodeIx) children:(List (nodeIx))

def Tree (nodeIx:Type) (a:Type) : Type =
  (nodeIx=>(Maybe (Node nodeIx a)) & nodeIx)
  -- Node array, and pointer to last used node.

def root (tree:Tree nodeIx a) : nodeIx =
  0@_ -- Convention

def isLeaf ((Branch _ _ children):Node node a) : Bool = 
  listLength children == 0

def isRoot ((Branch _ parent _):Node node a) : Bool = 
  isNothing parent

def initTree (maxSize:Int) (default_content:a) : Tree (Fin maxSize) a =
  root = Branch default_content Nothing (AsList 0 [])
  nothings = for i. Nothing
  initArray = yieldState nothings \ref. ref!(0@_) := (Just root)
  (initArray, 0@_)

def Game (state:Type) (move:Type) : Type =
  {
    possibleMoves : state -> (List move) &
    winOrLose : state -> Bool &
    update : state -> move -> state &
    gameOver : state -> Bool &
  }

def NodeStats (state:Type) : Type = 
  (Int & Int & Int & state)
  -- (#win, #loss, level, state)

' ### MCTS functions

def mcts_select (game: Game state move) (currRoot: nodeIx)
                (tree: Tree nodeIx (NodeStats state))
                (key: Key) : nodeIx = 
    yieldState currRoot \ref. iter \i.
      curr_node = fromJust (fst tree).(get ref)
      if isLeaf curr_node
        then Done ()
        else 
          (Branch _ _ children_list) = curr_node
          (AsList _ children) = children_list
          -- todo: UCT formula
          ref := children.(randIdx (hash key i))
          Continue


def expand (game: Game state move)
           (treeRef: Ref h (Tree nodeIx (NodeStats state)))
           (key: Key) (node: nodeIx) : {State h} (nodeIx & state) =
    -- assume `node` is a leaf node (base) and has a non-terminal state (base_state)
    
    -- extract info about the base node
    base_node = fromJust $ get (fstRef treeRef)!node
    (Branch base_stats base_parent _) = base_node
    (_, _, base_level, base_state) = base_stats

    -- prepare child nodes
    (AsList n base_moves) = (getAt #possibleMoves game) base_state
    child_nodes = for i.
      new_move = base_moves.i
      new_state = (getAt #update game) base_state new_move
      new_stats = (0, 0, base_level + 1, new_state)
      Branch new_stats (Just node) (toList [])

    -- write to the tree
    new_node = get (sndRef treeRef)
    base_children_ix = for i:(Fin n). new_node +! (1 + ordinal i)
    -- update base's children list
    new_base_node = Branch base_stats base_parent (toList base_children_ix)
    (fstRef treeRef)!node := Just new_base_node
    -- insert every child
    for i.
      child_ix = base_children_ix.i
      (fstRef treeRef)!child_ix := Just child_nodes.i
    sndRef treeRef := new_node +! n

    -- choose a random move
    move_ix = randIdx key
    new_move = base_moves.move_ix
    new_state = (getAt #update game) base_state new_move
    (base_children_ix.move_ix, new_state)


def rollout (game: Game state move)
            (key: Key) (currState: state) : Bool =
    -- result is w.r.t. the max player
    withState currState \ref. iter \i.
      curr_state = get ref
      (AsList _ new_moves) = (getAt #possibleMoves game) curr_state
      -- ^ should've been in the else block, but the compiler complains
      if (getAt #gameOver game) curr_state
        then
          result = (getAt #winOrLose game) curr_state
          Done $ xor (isEven i) result
        else
          new_move = new_moves.(randIdx (hash key i))
          ref := (getAt #update game) curr_state new_move
          Continue


def backpropagate [Eq nodeIx] (game: Game state move) (currRoot: nodeIx)
           (treeRef: Ref h (Tree nodeIx (NodeStats state)))
           (node: nodeIx) (newResult: Bool) : {State h} Unit =
    -- newResult: win or lose w.r.t max_player

    -- collect itself and all ancestors
    ancestors_list = yieldAccum (ListMonoid nodeIx) \ls.
      withState node \nodeRef. iter \_.
        append ls (get nodeRef)
        curr_node = fromJust $ get (fstRef treeRef)!(get nodeRef)
        (Branch _ curr_parent _) = curr_node
        if isNothing curr_parent || currRoot == (get nodeRef)
          then Done ()
          else
            nodeRef := fromJust curr_parent
            Continue

    -- update win and loss counts
    (AsList _ ancestors) = ancestors_list
    for i.
      -- unpack
      ancestor = fromJust $ get (fstRef treeRef)!(ancestors.i)
      (Branch stats parent children) = ancestor
      (win, loss, level, state) = stats
      -- compute
      (new_win, new_loss) = if xor newResult (isEven level)
        then (win + 1, loss)
        else (win, loss + 1)
      -- pack
      new_stats = (new_win, new_loss, level, state)
      (fstRef treeRef)!(ancestors.i) := Just (Branch new_stats parent children)
    ()

def mcts_sample [Eq nodeIx] (game: Game state move) (key: Key) (currRoot: nodeIx)
        (tree: Tree nodeIx (NodeStats state))
        : Tree nodeIx (NodeStats state) =
    [key1, key2, key3] = splitKey key
    leaf_ix = mcts_select game currRoot tree key1
    -- todo: this is a copy of the array for every sampling
    yieldState tree \treeRef.
      (child_ix, child_state) = expand game treeRef key2 leaf_ix
      result = rollout game key3 child_state
      backpropagate game currRoot treeRef child_ix result

' ### Toy game: Count 21

Count21State = Int
Count21Move = Int
Count21 : Game Count21State Count21Move = {
  possibleMoves = \_. toList [1,2],
  winOrLose = \sum. sum == 21,
  update = \sum move. sum + move,
  gameOver = \sum. sum >= 21,
}
key = newKey 0
init_node_stats : NodeStats Count21State = (0, 0, 0, 0)
-- (0 win, 0 loss, level 0, game state 0)
start_tree = initTree 12 init_node_stats
end_tree = fold start_tree \i:(Fin 5). -- sample five times
    mcts_sample Count21 (ixkey key i) (0@_)

end_tree

-- todo keep track of `moves`
