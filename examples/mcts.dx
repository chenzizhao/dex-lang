' ## Monte Carlo Tree Search
Follows the convention [here](http://www.incompleteideas.net/609%20dropbox/other%20readings%20and%20resources/MCTS-survey.pdf)\
Use safe-names-dev build\
TODOs
- flesh out backpropagate
- actual test cases (on minimax especially)

def (+!) {a} (n:a) (m:Int) : a = ((ordinal n) + m)@_
def xor (a:Bool) (b:Bool) : Bool = ((not a) && b) || (a && (not b))

' ### Tree types

data Node nodeIx a =
  Branch content:a parent:(Maybe nodeIx) children:(List (nodeIx))

def Tree (nodeIx:Type) (a:Type) : Type =
  (nodeIx=>(Maybe (Node nodeIx a)) & nodeIx)
  -- Node array, and pointer to last used node.

def root {nodeIx a} (tree:Tree nodeIx a) : nodeIx =
  0@_ -- Convention

def isLeaf {node a} ((Branch _ _ children):Node node a) : Bool = 
  listLength children == 0

def isRoot {node a} ((Branch _ parent _):Node node a) : Bool = 
  isNothing parent

def initTree {a} (maxSize:Int) (default_content:a) : Tree (Fin maxSize) a =
  root = Branch default_content Nothing (AsList 0 [])
  nothings = for i. Nothing
  initArray = yieldState nothings \ref. ref!(0@_) := (Just root)
  (initArray, 0@_)

def Game (state:Type) (move:Type) : Type =
  {
    possibleMoves : state -> (List move) &
    winOrLose : state -> Bool &
    update : state -> move -> state &
    gameOver : state -> Bool &
  }

def NodeStats (state:Type) : Type = 
  (Int & Int & Int & state)
  -- (#wins, #visit, level, state)

def node_win_visit_stats {nodeIx state} (node:(Node nodeIx (NodeStats state)))
  : (Int & Int) =
  (Branch stats _ _) = node
  (wins, visits, _, _) = stats
  (wins, visits)

def node_is_visited {nodeIx state} (node:(Node nodeIx (NodeStats state)))
  : Bool =
  (_, visits) = node_win_visit_stats node
  visits > 0

def node_state {nodeIx state} (node:(Node nodeIx (NodeStats state))) : state =
  (Branch stats _ _) = node
  (_, _, _, s) = stats
  s

def node_level {nodeIx state} (node:(Node nodeIx (NodeStats state))) : Int =
  (Branch stats _ _) = node
  (_, _, level, _) = stats
  level

' ### MCTS functions

def uct (win:Int) (n:Int) (parent_n:Int) : Float = 
  (IToF win) / (IToF n) + sqrt (2.0 / (IToF parent_n) * (log (IToF n)))

def mcts_select {move state nodeIx}
    (game: Game state move) (currRoot: nodeIx)
    (tree: Tree nodeIx (NodeStats state))
    (key: Key)
    : nodeIx = 
    arr = fst tree
    is_max_player = arr.currRoot |> fromJust |> node_level |> isEven

    yieldState currRoot \ref. iter \i.
      node = fromJust arr.(get ref)
      if isLeaf node
        then
          Done ()
        else
          (Branch _ _ children_list) = node
          (AsList _ children) = children_list
          fully_expanded = any for i.
            node_is_visited $ fromJust arr.(children.i)
          if not fully_expanded
            then
              (AsList _ unvisited) = (flip filter) children \child.
                not $ node_is_visited $ fromJust arr.child
              ref := unvisited.(randIdx key)
              Done ()
            else
              (_, p_visits) = node_win_visit_stats node
              -- selector = if is_max_player then argmax else argmin
              selector = if is_max_player then argmax else argmax
              best_child = selector for i.
                child = fromJust arr.(children.i)
                (win, visits) = node_win_visit_stats child
                uct win visits p_visits
              ref := children.best_child
              Continue


def expand {move state nodeIx h}
    (game: Game state move)
    (treeRef: Ref h (Tree nodeIx (NodeStats state)))
    (key: Key) (node: nodeIx) : {State h} Unit =
    -- assume `node` is a leaf node (base) and has a non-terminal state (base_state)

    -- extract info about the base node
    base_node = fromJust $ get (fstRef treeRef)!node
    (Branch base_stats base_parent _) = base_node
    (_, _, base_level, base_state) = base_stats

    -- prepare child nodes
    (AsList n base_moves) = (getAt #possibleMoves game) base_state
    child_nodes = for i.
      new_move = base_moves.i
      new_state = (getAt #update game) base_state new_move
      new_stats = (0, 0, base_level + 1, new_state)
      Branch new_stats (Just node) (toList [])

    -- write to the tree
    new_node = get (sndRef treeRef)
    base_children_ix = for i:(Fin n). new_node +! (1 + ordinal i)
    -- update base's children list
    new_base_node = Branch base_stats base_parent (toList base_children_ix)
    (fstRef treeRef)!node := Just new_base_node
    -- insert every child
    for i.
      child_ix = base_children_ix.i
      (fstRef treeRef)!child_ix := Just child_nodes.i
    sndRef treeRef := new_node +! n


def rollout {move state}
    (game: Game state move)
    (key: Key) (currState: state) : Bool =
    -- output is w.r.t. current player
    withState currState \ref. iter \i.
      curr_state = get ref
      (AsList _ new_moves) = (getAt #possibleMoves game) curr_state
      -- ^ should've been in the else block, but the compiler complains
      if (getAt #gameOver game) curr_state
        then
          -- #winOrLose is w.r.t. the last player
          result = (getAt #winOrLose game) curr_state
          Done $ xor (isEven i) result
        else
        -- rollout policy: uniform random
          new_move = new_moves.(randIdx (hash key i))
          ref := (getAt #update game) curr_state new_move
          Continue


def backpropagate {move state nodeIx} {h} [Eq nodeIx] 
    (game: Game state move) (currRoot: nodeIx)
    (treeRef: Ref h (Tree nodeIx (NodeStats state)))
    (node: nodeIx) (newResult: Bool) : {State h} Unit =
    -- newResult: win or lose w.r.t curr_player @node

    leaf_not_max_player = get (fstRef treeRef)!node |>
      fromJust |> node_level |> isOdd
    maxResult = xor newResult leaf_not_max_player
    -- maxResult: win or lose w.r.t. max player

    -- collect itself and all ancestors
    ancestors_list = yieldAccum (ListMonoid nodeIx) \ls.
      withState node \nodeRef. iter \_.
        append ls (get nodeRef)
        curr_node = fromJust $ get (fstRef treeRef)!(get nodeRef)
        (Branch _ curr_parent _) = curr_node
        if isNothing curr_parent || currRoot == (get nodeRef)
          then Done ()
          else
            nodeRef := fromJust curr_parent
            Continue

    -- update win and loss counts
    (AsList _ ancestors) = ancestors_list
    for i.
      -- unpack
      ancestor = fromJust $ get (fstRef treeRef)!(ancestors.i)
      (Branch stats parent children) = ancestor
      (wins, visits, level, state) = stats
      -- compute
      ancestor_not_max_player = isOdd level
      -- todo
      ancestorResult = xor maxResult ancestor_not_max_player
      (new_wins, new_visits) = if ancestorResult
        then (wins + 1, visits + 1)
        else (wins - 1, visits + 1)
      -- pack
      new_stats = (new_wins, new_visits, level, state)
      (fstRef treeRef)!(ancestors.i) := Just (Branch new_stats parent children)
    ()

def mcts_sample {move state nodeIx} [Eq nodeIx]
    (game: Game state move) (key: Key) (currRoot: nodeIx)
    (tree: Tree nodeIx (NodeStats state))
    : Tree nodeIx (NodeStats state) =
    [key1, key2, key3] = splitKey key
    leaf_ix = mcts_select game currRoot tree key1
    leaf = fromJust (fst tree).leaf_ix
    -- todo: this is a copy of the array for every sampling
    yieldState tree \treeRef.
      if not $ (getAt #gameOver game) $ node_state leaf then
        expand game treeRef key2 leaf_ix
      result = rollout game key3 $ node_state leaf
      backpropagate game currRoot treeRef leaf_ix result

def mcts_choose {move state nodeIx} [Eq nodeIx]
  (game: Game state move) (currRoot: nodeIx)
  (tree: Tree nodeIx (NodeStats state))
  : nodeIx = -- not the best, should return a move to uncover states
    arr = fst tree
    node = fromJust arr.currRoot
    is_max_player = isEven $ node_level node
    (Branch _ _ children_list) = node
    (AsList _ children) = children_list
    (_, p_visits) = node_win_visit_stats node
    -- selector = if is_max_player then argmax else argmin
    selector = if is_max_player then argmax else argmax
    best_child = selector for i.
      child = fromJust arr.(children.i)
      (win, visits) = node_win_visit_stats child
      uct win visits p_visits
    children.best_child


' ### Toy game: Count 21

Count21State = Int
Count21Move = Int
Count21 : Game Count21State Count21Move = {
  possibleMoves = \_. toList [1,2],
  winOrLose = \sum. sum == 21,
  update = \sum move. sum + move,
  gameOver = \sum. sum >= 21,
}
key = newKey 0
init_node_stats : NodeStats Count21State = (0, 0, 0, 19)
-- (0 wins, 0 visits, level 0, game state 0)
start_tree = initTree 12 init_node_stats
end_tree = fold start_tree \i:(Fin 10). -- sample five times
    mcts_sample Count21 (ixkey key i) (0@_)

end_tree

game = Count21

mcts_choose game (0@_) end_tree

tree = start_tree

[key1, key2, key3] = splitKey key
leaf_ix = mcts_select game (0@_) tree key1
leaf = fromJust (fst tree).leaf_ix

leaf

res1 = runState tree \treeRef.
  if not $ (getAt #gameOver game) $ node_state leaf
    then expand game treeRef key2 leaf_ix
  result = rollout game key3 $ node_state leaf
  backpropagate game (0@_) treeRef leaf_ix result
  result

res1

rollout game key3 21

