' ## Monte Carlo Tree Search
Follows the convention [here](http://www.incompleteideas.net/609%20dropbox/other%20readings%20and%20resources/MCTS-survey.pdf)\
Use safe-names-dev build\
TODOs
- coordinate `mcts_select` and `expand`
- (win, loss) -> (win, visited)?
- flesh out backpropagate
- actual test cases (on minimax especially)

def (+!) {a} (n:a) (m:Int) : a = ((ordinal n) + m)@_
def xor (a:Bool) (b:Bool) : Bool = ((not a) && b) || (a && (not b))

' ### Tree types

data Node nodeIx a =
  Branch content:a parent:(Maybe nodeIx) children:(List (nodeIx))

def Tree (nodeIx:Type) (a:Type) : Type =
  (nodeIx=>(Maybe (Node nodeIx a)) & nodeIx)
  -- Node array, and pointer to last used node.

def root {nodeIx a} (tree:Tree nodeIx a) : nodeIx =
  0@_ -- Convention

def isLeaf {node a} ((Branch _ _ children):Node node a) : Bool = 
  listLength children == 0

def isRoot {node a} ((Branch _ parent _):Node node a) : Bool = 
  isNothing parent

def initTree {a} (maxSize:Int) (default_content:a) : Tree (Fin maxSize) a =
  root = Branch default_content Nothing (AsList 0 [])
  nothings = for i. Nothing
  initArray = yieldState nothings \ref. ref!(0@_) := (Just root)
  (initArray, 0@_)

def Game (state:Type) (move:Type) : Type =
  {
    possibleMoves : state -> (List move) &
    winOrLose : state -> Bool &
    update : state -> move -> state &
    gameOver : state -> Bool &
  }

def NodeStats (state:Type) : Type = 
  (Int & Int & Int & state)
  -- (#win, #loss, level, state)

def win_loss_stats {nodeIx state} (node:(Node nodeIx (NodeStats state))) : (Int & Int) = 
  (Branch stats parent _) = node
  (win, loss, _, _) = stats
  (win, loss)

def is_visited {nodeIx state} (node:(Node nodeIx (NodeStats state))) : Bool = 
  (win, loss) = win_loss_stats node
  (win + loss) > 0


' ### MCTS functions

def uct (win:Int) (n:Int) (parent_n:Int) : Float = 
  (IToF win) / (IToF n) + sqrt (2.0 / (IToF parent_n) * (log (IToF n)))

def mcts_select {move state nodeIx}
    (game: Game state move) (currRoot: nodeIx)
    (tree: Tree nodeIx (NodeStats state))
    : nodeIx = 
    arr = fst tree
    if isLeaf $ fromJust arr.currRoot
      then currRoot
      else
        yieldState currRoot \ref. iter \i.
          node = fromJust arr.(get ref)
          (Branch _ _ children_list) = node
          (AsList _ children) = children_list
          fully_expanded = any for i.
            is_visited $ fromJust arr.(children.i)

          if not fully_expanded
            then
              -- expand it
              Done ()
            else
              (win, loss) = win_loss_stats node
              p_n = win + loss
              best_child = argmax for i.
                child = fromJust arr.(children.i)
                (win, loss) = win_loss_stats child
                uct win (win + loss) p_n
              ref := children.best_child
              Continue


def expand {move state nodeIx h}
    (game: Game state move)
    (treeRef: Ref h (Tree nodeIx (NodeStats state)))
    (key: Key) (node: nodeIx) : {State h} (nodeIx & state) =
    -- assume `node` is a leaf node (base) and has a non-terminal state (base_state)
    
    -- extract info about the base node
    base_node = fromJust $ get (fstRef treeRef)!node
    (Branch base_stats base_parent _) = base_node
    (_, _, base_level, base_state) = base_stats

    -- prepare child nodes
    (AsList n base_moves) = (getAt #possibleMoves game) base_state
    child_nodes = for i.
      new_move = base_moves.i
      new_state = (getAt #update game) base_state new_move
      new_stats = (0, 0, base_level + 1, new_state)
      Branch new_stats (Just node) (toList [])

    -- write to the tree
    new_node = get (sndRef treeRef)
    base_children_ix = for i:(Fin n). new_node +! (1 + ordinal i)
    -- update base's children list
    new_base_node = Branch base_stats base_parent (toList base_children_ix)
    (fstRef treeRef)!node := Just new_base_node
    -- insert every child
    for i.
      child_ix = base_children_ix.i
      (fstRef treeRef)!child_ix := Just child_nodes.i
    sndRef treeRef := new_node +! n

    -- choose a random move
    move_ix = randIdx key
    new_move = base_moves.move_ix
    new_state = (getAt #update game) base_state new_move
    (base_children_ix.move_ix, new_state)


def rollout {move state}
    (game: Game state move)
    (key: Key) (currState: state) : Bool =
    -- result is w.r.t. the max player
    withState currState \ref. iter \i.
      curr_state = get ref
      (AsList _ new_moves) = (getAt #possibleMoves game) curr_state
      -- ^ should've been in the else block, but the compiler complains
      if (getAt #gameOver game) curr_state
        then
          result = (getAt #winOrLose game) curr_state
          Done $ xor (isEven i) result
        else
        -- rollout policy: uniform random
          new_move = new_moves.(randIdx (hash key i))
          ref := (getAt #update game) curr_state new_move
          Continue


def backpropagate {move state nodeIx} {h} [Eq nodeIx] 
    (game: Game state move) (currRoot: nodeIx)
    (treeRef: Ref h (Tree nodeIx (NodeStats state)))
    (node: nodeIx) (newResult: Bool) : {State h} Unit =
    -- newResult: win or lose w.r.t max_player

    -- collect itself and all ancestors
    ancestors_list = yieldAccum (ListMonoid nodeIx) \ls.
      withState node \nodeRef. iter \_.
        append ls (get nodeRef)
        curr_node = fromJust $ get (fstRef treeRef)!(get nodeRef)
        (Branch _ curr_parent _) = curr_node
        if isNothing curr_parent || currRoot == (get nodeRef)
          then Done ()
          else
            nodeRef := fromJust curr_parent
            Continue

    -- update win and loss counts
    (AsList _ ancestors) = ancestors_list
    for i.
      -- unpack
      ancestor = fromJust $ get (fstRef treeRef)!(ancestors.i)
      (Branch stats parent children) = ancestor
      (win, loss, level, state) = stats
      -- compute
      (new_win, new_loss) = if xor newResult (isEven level)
        then (win + 1, loss)
        else (win, loss + 1)
      -- pack
      new_stats = (new_win, new_loss, level, state)
      (fstRef treeRef)!(ancestors.i) := Just (Branch new_stats parent children)
    ()

def mcts_sample {move state nodeIx} [Eq nodeIx]
    (game: Game state move) (key: Key) (currRoot: nodeIx)
    (tree: Tree nodeIx (NodeStats state))
    : Tree nodeIx (NodeStats state) =
    [key1, key2, key3] = splitKey key
    -- most certainly not a leaf here. 
    leaf_ix = mcts_select game currRoot tree
    -- todo: this is a copy of the array for every sampling
    yieldState tree \treeRef.
      (child_ix, child_state) = expand game treeRef key2 leaf_ix
      result = rollout game key3 child_state
      backpropagate game currRoot treeRef child_ix result

' ### Toy game: Count 21

Count21State = Int
Count21Move = Int
Count21 : Game Count21State Count21Move = {
  possibleMoves = \_. toList [1,2],
  winOrLose = \sum. sum == 21,
  update = \sum move. sum + move,
  gameOver = \sum. sum >= 21,
}
key = newKey 0
init_node_stats : NodeStats Count21State = (0, 0, 0, 0)
-- (0 win, 0 loss, level 0, game state 0)
start_tree = initTree 12 init_node_stats
end_tree = fold start_tree \i:(Fin 5). -- sample five times
    mcts_sample Count21 (ixkey key i) (0@_)

end_tree
