
' ## Barnes-Hut algorithm for the N body problem
[https://jheer.github.io/barnes-hut/](https://jheer.github.io/barnes-hut/)

' ### Quadtree

D = 2
S = intpow2 D

data Node a b node =
    Branch cnodes:((Fin S)=>(Maybe node))   pnode:(Maybe node)  nodedata:b
    Leaf   leafdata:a                       pnode:(Maybe node)  nodedata:b
    Unused

def Tree (a:Type) (b:Type) (node:Type) : Type = node => (Node a b node)

def replaceInTable [Eq n] (ind:n) (val:v) (vals:n=>v): n=>v = 
    yieldState vals \ref. ref!ind := val

def (+!) (n:a) (m:Int) : a = ((ordinal n) + m)@_
def (-!) (x:n) (z:Int) : n = ((ordinal x)-z)@n

def isBranch (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> True
        Leaf _ _ _ -> False
        Unused -> False

def isLeaf (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> False
        Leaf _ _ _ -> True
        Unused -> False

def isUnused (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> False
        Leaf _ _ _ -> False
        Unused -> True

def getNodeData (n:Node a b node) : b = 
    case n of
        Branch _ _ nodedata -> nodedata
        Leaf _ _ nodedata -> nodedata
        Unused -> error "cannot get nodedata of unused node"

def extendLeaf1
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (leafid:node)
    (valsid:(Fin S))
    (val:a)
    : {State h} node =
    headId = get headIdref
    (leafdata,leafpid,leafnodedata) = case (get arrref!leafid)of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> (replaceInTable valsid (Just headId))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    arrref!leafid := newbranch
    arrref!headId := newleaf
    headIdref := headId+!1
    headId

def extendLeaf2
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (leafid:node)
    (leafsid:(Fin S))
    (valsid:(Fin S))
    (val:a)
    : {State h} Unit =
    headId = get headIdref
    (leafdata,leafpid,leafnodedata) = case (get arrref!leafid) of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> 
        (replaceInTable leafsid (Just headId)) |> 
        (replaceInTable valsid (Just (headId+!1)))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    newval = Leaf val (Just leafid) (initNodeData newbranch val)
    arrref!leafid := newbranch
    arrref!headId := newleaf
    arrref!(headId+!1) := newval
    headIdref := headId+!2

def parentOfVal -- read only
    (decide:(Node a b node)->a->(Fin S)) 
    (arrref:Ref h (Tree a b node))
    (val:a)
    : {State h} node =
    yieldState (0@_) \cid.
        while \(). 
            cnode:(Node a b node) = get arrref!(get cid)
            case cnode of
                Unused -> False
                Leaf _ _ _ -> False
                Branch cnodes _ _ ->
                    ind = decide cnode val
                    case cnodes.ind of 
                        Just id -> 
                            cid := id
                            True
                        Nothing -> False

-- API
def insertElement
    (decide:(Node a b node)->a->(Fin S)) -- domain specific
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (val:a)
    : {State h} Unit =
    headId = get headIdref
    -- find appropriate parent node (read only)
    pId:node = parentOfVal decide arrref val
    -- modify the tree
    pnode = get arrref!pId
    case pnode of 
        Unused ->
            newleaf = Leaf val Nothing (initNodeData pnode val)
            arrref!pId := newleaf
            headIdref := headId+!1
        Branch cnodes ppnode bdata ->
            valsid = decide pnode val
            newcnodes = cnodes |> 
                (replaceInTable valsid (Just headId)) -- overwriting Nothing
            newbranch = Branch newcnodes ppnode bdata
            newleaf = Leaf val (Just pId) (initNodeData pnode val)
            arrref!pId := newbranch
            arrref!headId := newleaf
            headIdref := headId+!1
        Leaf pval _ _ ->
            -- uses pval and tree
            -- push this leaf down, until psid != valsid
            withState pId \leafidref.
                extendLeaf1' = extendLeaf1 initNodeData headIdref arrref
                extendLeaf2' = extendLeaf2 initNodeData headIdref arrref
                while \().
                    leafid = get leafidref
                    psid = decide (get arrref!leafid) pval
                    valsid = decide (get arrref!leafid) val
                    case psid == valsid of
                        True ->
                            leafidref := extendLeaf1' leafid valsid val
                            True
                        False -> 
                            extendLeaf2' leafid psid valsid val
                            False

-- API
def updateAllNodeData
    (updateBranchData:(Ref h (Tree a b node))->(Node a b node)->{State h}(Node a b node))
    (arrref:Ref h (Tree a b node))
    : {State h} Unit =
    rof i.
        node = get arrref!i
        if isBranch node then
            cbranch = node
            arrref!i := updateBranchData arrref cbranch
    ()

' ### Domain specific setups

def Vec (d:Int) : Type = (Fin d)=>Float
BBox = ((Vec D)&(Vec D))

Body = {
  m:Float
  & pos:Vec D
}

NodeData = {
    bb:BBox
  & m:Float
  & com:Vec D
}

' #### Bounding box utilities

def bbWidth ((low, high):BBox) : Float =
    (high.(0@_) - low.(0@_))

def center ((low, high):BBox) : Vec D =
    half = (bbWidth (low, high)) / 2.
    for d. low.d + half

def subQuad ((low, high):BBox) (pos:Vec D) : Fin S =
    [mid_x, mid_y] = center (low, high)
    [pos_x, pos_y] = pos
    bit1 = BToW8 $ pos_x > mid_x
    bit2 = BToW8 $ pos_y > mid_y
    bits = W8ToI $ bit1 .|. (bit2 .<<. 1)
    bits@_

def subBox ((low, high):BBox) (pos:Vec D) : BBox =
    -- assume pos in BBox
    half = (bbWidth (low, high)) / 2.
    newlow = for d. low.d + half * (floor ((pos.d-low.d)/half))
    newhigh = for d. newlow.d + half
    (newlow, newhigh)

' #### Two functions needed in insertElement

-- API
def initNodeDataFn (pnode:Node body NodeData node) (val:Body) : NodeData =
    case pnode of 
        Unused -> 
            bbox = ([0., 0.], [1.,1.])
            pos = getAt #pos val
            { bb=bbox, m=(getAt #m val), com=pos }
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }

-- API
def decide (pnode:Node body NodeData node) (val:Body) : (Fin S) =
    case pnode of 
        Unused -> error "Function decide shouldn't be called on unused node"
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos


' #### One function needed in updateAllNodeData

def summarizeChildNodes
    (arrref:Ref h (Tree body NodeData node))
    (cnodes:(Fin S)=>(Maybe node))
    : {State h} (Float & Float & Float) =
    [m, xmom, ymom] = yieldAccum (AddMonoid Float) \ref. 
        for i.
            cnode = cnodes.i
            case cnode of 
                Nothing -> ()
                Just id -> 
                    nodedata = getNodeData (get arrref!id)
                    m = getAt #m nodedata
                    [x,y] = getAt #com nodedata
                    ref += [m, x*m, y*m]
    (m, xmom/m, ymom/m)

-- API
def updateBranchData 
    (arrref:Ref h (Tree body NodeData node))
    (bnode:Node Body NodeData node)
    : {State h} Node body NodeData node =
    case bnode of 
        Leaf _ _ _ -> error "shouldn't be called on leaves"
        Unused -> error "shouldn't be called on unused nodes"
        Branch cnodes pnode nodedata -> 
            (mass, xbar, ybar) = summarizeChildNodes arrref cnodes
            nodedata' = nodedata |> 
                setAt #m mass |>
                setAt #com [xbar, ybar]
            (Branch cnodes pnode nodedata')


' #### Estimate N-body forces

' ##### Calculate forces

gravity = 6.674286e-11  -- units?

-- more like a = F/m = Gm'/d2
def force (otherpos:Vec D) (othermass:Float) (pos:Vec D) : Vec D = 
    case otherpos == pos of
        True -> zero
        False -> 
            diff = otherpos - pos
            distance = sqrt $ vdot diff diff
            gf = gravity * othermass / (sq distance)
            gf .* diff / distance

def force' (nodedata:NodeData) (pos:Vec D) : Vec D = 
    mass = getAt #m nodedata
    com = getAt #com nodedata
    force com mass pos

def widthDistanceRatio (n:Node body NodeData node) (pos:Vec D) : Float =
    nodedata = getNodeData n
    width = bbWidth $ getAt #bb nodedata
    diff = pos - (getAt #com nodedata)
    distance = sqrt $ vdot diff diff
    width/distance

' ##### Stack utilities

def Stack (slot:Type) (a:Type) : Type = ((slot=>a)&slot)

def push (stackRef:Ref h (Stack slot a)) (x:a) : {State h} Unit =
    arrRef = fstRef stackRef
    headRef = sndRef stackRef
    currHead = get headRef
    arrRef!currHead := x
    headRef := currHead +! 1

def pop (stackRef:Ref h(Stack slot a)) (_:Unit) : {State h} a =
    arrRef = fstRef stackRef
    headRef = sndRef stackRef
    currHead = get headRef
    prevHead = currHead -! 1
    x = get arrRef!prevHead
    -- arrRef!prevHead := default
    headRef := prevHead
    x

' ##### Probe by traversing the tree

-- Tune me!
N_stack = 50 -- ~ depth * 8 ~ log8 (N) * 8

-- def initStack : Stack (Fin N_stack) NodeId =
--     arr = for _. (0@NodeId)
--     (arr, 1@_)

-- API
def probe (arr:Tree body NodeData node) (theta:Float) (pos:Vec D) : Vec D =
    initStack : Stack (Fin N_stack) node =
        arr = for _. (0@node)
        (arr, 1@_)
    yieldState zero \forceRef.
        withState initStack \sRef.
            pop' = pop sRef
            push' = push sRef
            headRef = sndRef sRef
            while \().
                id = pop' ()
                curr_node = arr.id
                ratio = widthDistanceRatio curr_node pos
                case ratio <= theta of
                    True -> -- long range force
                        nodedata = getNodeData curr_node
                        forceRef := (get forceRef) + (force' nodedata pos)
                    False -> -- short range force
                        case curr_node of
                            Unused -> error "impossible to reach"
                            Leaf _ _ nodedata ->
                                forceRef := (get forceRef) + (force' nodedata pos)
                            Branch cnodes _ _ ->
                                for i. if isJust cnodes.i
                                    then push' (fromJust cnodes.i)
                                ()
                ((ordinal (get headRef)) > 0)

-- API: Benchmark
def pairwiseProbe (bodies:bodyid=>Body) (pos:Vec D) : Vec D =
    yieldAccum (AddMonoid Float) \forceRef.
        for i. 
            body = bodies.i
            m = getAt #m body
            p = getAt #pos body
            forceRef += force p m pos

' ### Test

' #### Synthetic data

-- Change me!
BodyInd = Fin 20

[k1,k2] = splitKey (newKey 0)
initPos : BodyInd=>Vec D = for i j. rand $ ixkey2 k1 i j
initVel : BodyInd=>Vec D = for i j. rand $ ixkey2 k2 i j
masses  : BodyInd=>Float = for i. 1.0e11 .* (rand $ ixkey k1 i)
bodies  : BodyInd=>Body  = for i. { m=masses.i, pos=initPos.i, }

-- :p initPos
-- :p bodies

' #### Insert all elements

def buildTree (bodies:body=>Body) : Tree Body NodeData node =
    inithead = 0@node
    initarr  = for i. Unused
    (_, tree) = yieldState (inithead, initarr) \ref.
        insertElement' = insertElement decide initNodeDataFn (fstRef ref) (sndRef ref)
        for i. insertElement' bodies.i
        updateAllNodeData' = updateAllNodeData updateBranchData
        updateAllNodeData' (sndRef ref)
    tree

-- Change me!
NodeId = Fin 40 -- usually doubles number of bodies in the system

%time
tree : Tree Body NodeData NodeId = buildTree bodies
-- :p tree

' #### Probing

' $\theta = 0.0$ makes sure that all leaves are reached

testPos1 = [1.0, 1.0]

%time
probe tree (0.0) testPos1

%time
pairwiseProbe bodies testPos1

' Increasing $\theta$ allows for faster but less accutate result

testPos2 = [10., 10.]

%time
probe tree (0.0) testPos2

%time
probe tree (0.2) testPos2

%time
probe tree (5.0) testPos2

' Is BH faster than bruteforce? 
Yes, only when body number > 200 with $\theta$=1.0

%time
forces1 =
    probe' = probe tree (1.0)
    for i. probe' initPos.i

%time
forces2 = for i. pairwiseProbe bodies initPos.i

loss = mean for i.
    diff = forces1.i - forces2.i
    sum $ map abs diff

:p loss

' ### Simulation

Position = (Fin D)=>Float
Velocity = (Fin D)=>Float
Force = (Fin D)=>Float
Mass = Float

data BodyState = 
    MkBodyState Mass Position Velocity

init_state : BodyInd=>BodyState = for i.
    mass=masses.i
    pos=initPos.i
    vel=initVel.i
    (MkBodyState mass pos vel)

def state2body ((MkBodyState mass pos _):BodyState) : Body = 
    {
        m=mass,
        pos=pos
    }

def body2state (b:Body) (vel:Velocity) : BodyState = 
    m = getAt #m b
    pos = getAt #pos b
    (MkBodyState m pos vel)

dt = 0.0001
Times = Fin 70

def update (bodystates:n=>BodyState) (dt:Float) : n=>BodyState =
  -- Updates all the body states.
  bodies = map state2body bodystates
  tree : Tree Body NodeData (Fin 40) = buildTree bodies
  theta = 1.0
  for i.
    -- Todo: don't compute forces with yourself when for ranges are fixed.
    (MkBodyState mass pos vel) = bodystates.i
    f = probe tree theta pos
    -- Todo: use a better integrator.
    vel' = vel + dt .* f  -- Euler integrator.
    pos' = pos + dt .* vel  -- Euler integrator
    (MkBodyState mass pos' vel')

def step (_:Times) (bodies:n=>BodyState) : n=>BodyState = 
  update bodies dt

-- Versions of scan that explicity take the index set n.
def scan'' (init:a) (n:Type) (body:n->a->(a&b)) : (a & n=>b) =
  swap $ runState init \s. for i.
    c = get s
    (c', y) = body i c
    s := c'
    y

def scan''' (init:a) (n:Type) (body:n->a->a) : n=>a =
  snd $ scan'' init n \i x. dup (body i x)

history = scan''' init_state Times step

:t history

coords = for t:Times i:BodyInd.
  (MkBodyState _ p _) = history.t.i
  [p.(0@_), p.(1@_), masses.i] -- x, y, mass

def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : (Fin 3)=>Float =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]

def pathImgs (coords:t=>n=>(Fin 3)=>Float) : t=>h=>w=>(Fin 3)=>Float = 
    size_h = IToF $ size h
    size_w = IToF $ size w
    max_mass = maximum masses
    yieldAccum (AddMonoid Float) \imgs.
        for tt i.
            [x,y,m] = coords.tt.i
            hx' = FToI $ round $ clip (0.0,1.0) x * (size_h-1.)
            wy' = FToI $ round $ clip (0.0,1.0) y * (size_w-1.)
            hx = (hx'@_)
            wy = (wy'@_)
            c = m/max_mass
            imgs!tt!hx!wy += zero + hslToRgb c 1.0 0.5
        ()

imgs : Times=>(Fin 200)=>(Fin 200)=>(Fin 3)=>Float = pathImgs coords

import png

:html imseqshow imgs
