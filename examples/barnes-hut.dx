
' ## Barnes-Hut algorithm for the N body problem
https://jheer.github.io/barnes-hut/

' ### Quadtree

D = 2
S = intpow2 D

data Node a b node =
    Branch cnodes:((Fin S)=>(Maybe node))   pnode:(Maybe node)  nodedata:b
    Leaf   leafdata:a                       pnode:(Maybe node)  nodedata:b
    Unused

data Tree a b node =
    TreeArray head:node     arr:(node=>(Node a b node))

def replaceInTable [Eq n] (ind:n) (val:v) (vals:n=>v): n=>v = 
    yieldState vals \ref. ref!ind := val

def (+!) (n:a) (m:Int) : a = ((ordinal n) + m)@_

def isBranch (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> True
        Leaf _ _ _ -> False
        Unused -> False

def getNodeData (n:Node a b node) : b = 
    case n of
        Branch _ _ nodedata -> nodedata
        Leaf _ _ nodedata -> nodedata
        Unused -> error "cannot get nodedata of unused node"

def extendLeaf1 [Eq node]
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (tree:Tree a b node)
    (leafid:node)
    (valsid:(Fin S))
    (val:a)
    : ((Tree a b node)&node) =
    (TreeArray headId arr) = tree
    (leafdata,leafpid,leafnodedata) = case arr.leafid of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> (replaceInTable valsid (Just headId))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    newarr = arr |>
        (replaceInTable leafid newbranch) |>
        (replaceInTable headId newleaf)
    ((TreeArray (headId+!1) newarr), headId)

def extendLeaf2 [Eq node]
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (tree:Tree a b node)
    (leafid:node)
    (leafsid:(Fin S))
    (valsid:(Fin S))
    (val:a)
    : (Tree a b node) =
    (TreeArray headId arr) = tree
    (leafdata,leafpid,leafnodedata) = case arr.leafid of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> 
        (replaceInTable leafsid (Just headId)) |> 
        (replaceInTable valsid (Just (headId+!1)))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    newval = Leaf val (Just leafid) (initNodeData newbranch val)
    newarr = arr |>
        (replaceInTable leafid newbranch) |>
        (replaceInTable headId newleaf) |>
        (replaceInTable (headId+!1) newval)
    (TreeArray (headId+!2) newarr)

-- API
def insertElement [Eq node]
    (decide:(Node a b node)->a->(Fin S)) -- domain specific
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (tree:Tree a b node)
    (val:a)
    : Tree a b node = 
    (TreeArray headId arr) = tree
    -- find appropriate parent node (read only)
    pId:node = yieldState (0@_) \cid.
        while \(). 
            cnode = arr.(get cid)
            case cnode of
                Unused -> False
                Leaf _ _ _ -> False
                Branch cnodes _ _ ->
                    ind = decide cnode val
                    case cnodes.ind of 
                        Just id -> 
                            cid := id
                            True
                        Nothing -> False
    -- modify the tree
    pnode = arr.pId
    case pnode of 
        Unused ->
            newleaf = Leaf val Nothing (initNodeData pnode val)
            newarr = arr |> 
                (replaceInTable pId newleaf)
            TreeArray (headId+!1) newarr
        Branch cnodes ppnode bdata ->
            valsid = decide pnode val
            newcnodes = cnodes |> 
                (replaceInTable valsid (Just headId)) -- overwriting Nothing
            newbranch = Branch newcnodes ppnode bdata
            newleaf = Leaf val (Just pId) (initNodeData pnode val)
            newarr = arr |>
                (replaceInTable pId newbranch) |>
                (replaceInTable headId newleaf)
            TreeArray (headId+!1) newarr
        Leaf pval _ _ ->
            extendLeaf1' = extendLeaf1 initNodeData
            extendLeaf2' = extendLeaf2 initNodeData
            -- uses pval and tree
            -- push this leaf down, until psid != valsid
            (newpid, newtree) = runState tree \tref.
                yieldState pId \leafidref.
                    while \().
                        tree = get tref
                        leafid = get leafidref
                        (TreeArray _ arr) = tree
                        psid = decide arr.leafid pval
                        valsid = decide arr.leafid val
                        case psid == valsid of
                            True ->
                                (newtree, newleafid) = extendLeaf1' tree leafid valsid val
                                tref := newtree
                                leafidref := newleafid
                                True
                            False -> False
            -- safely replace newleaf with a branch of two leaves: pval and val
            (TreeArray _ newarr) = newtree
            leafsid = decide newarr.newpid pval
            valsid = decide newarr.newpid val
            extendLeaf2' newtree newpid leafsid valsid val

-- todo this can be combined with insertElement in theory
-- pro: compute center of masses in one go
-- con: may complicate insertElement
-- API
def updateAllNodeData
    (updateBranchData:(Tree a b node)->(Node a b node)->(Node a b node))
    -- domain specific
    (tree:Tree a b node) : Tree a b node = 
    (TreeArray headId arr) = tree
    (AsList _ branchIds) = argFilter isBranch arr
    arr2 = yieldState arr \ref. rof i.
        ctree = TreeArray headId (get ref)
        cbranch = get $ ref!(branchIds.i)
        ref!(branchIds.i) := updateBranchData ctree cbranch
    (TreeArray headId arr2)


' ### Domain specific setups

NodeId = Fin 20
BodyInd = Fin 8
def Vec (d:Int) : Type = (Fin d)=>Float
BBox = ((Vec D)&(Vec D))

Body = {
    ind:BodyInd
  & m:Float
  & pos:Vec D
--   & vel:Vec D
--   & nodeId:NodeId
}

NodeData = {
    bb:BBox
  & m:Float
  & com:Vec D
}

' #### Bounding box utilities

def bbWidth ((low, high):BBox) : Float =
    (high.(0@_) - low.(0@_))

def center ((low, high):BBox) : Vec D =
    half = (bbWidth (low, high)) / 2.
    for d. low.d + half

def subQuad ((low, high):BBox) (pos:Vec D) : Fin S =
    [mid_x, mid_y] = center (low, high)
    [pos_x, pos_y] = pos
    bit1 = BToW8 $ pos_x > mid_x
    bit2 = BToW8 $ pos_y > mid_y
    bits = W8ToI $ bit1 .|. (bit2 .<<. 1)
    bits@_

def subBox ((low, high):BBox) (pos:Vec D) : BBox =
    -- assume pos in BBox
    half = (bbWidth (low, high)) / 2.
    newlow = for d. low.d + half * (floor ((pos.d-low.d)/half))
    newhigh = for d. newlow.d + half
    (newlow, newhigh)

' #### Two functions needed in insertElement

-- API
def initNodeDataFn (pnode:Node Body NodeData NodeId) (val:Body) : NodeData = 
    case pnode of 
        Unused -> 
            bbox = ([-2., -2.], [2.,2.])
            pos = getAt #pos val
            { bb=bbox, m=(getAt #m val), com=pos }
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }

-- API
def decide (pnode:Node Body NodeData NodeId) (val:Body) : (Fin S) = 
    case pnode of 
        Unused -> error "Function decide shouldn't be called on unused node"
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos


' #### One function needed in updateAllNodeData

def summarizeChildNodes
    (tree:Tree Body NodeData NodeId)
    (cnodes:(Fin S)=>(Maybe NodeId))
    : (Float & Float & Float) =
    (TreeArray _ arr) = tree
    [m, xmom, ymom] = yieldAccum (AddMonoid Float) \ref. 
        for i.
            cnode = cnodes.i
            case cnode of 
                Nothing -> ()
                Just id -> 
                    nodedata = getNodeData arr.id
                    m = getAt #m nodedata
                    [x,y] = getAt #com nodedata
                    ref += [m, x*m, y*m]
    (m, xmom/m, ymom/m)

-- API
def updateBranchData 
    (tree:Tree Body NodeData NodeId) 
    (bnode:Node Body NodeData NodeId)
    : Node Body NodeData NodeId = 
    case bnode of 
        Leaf _ _ _ -> error "shouldn't be called on leaves"
        Unused -> error "shouldn't be called on unused nodes"
        Branch cnodes pnode nodedata -> 
            (mass, xbar, ybar) = summarizeChildNodes tree cnodes
            nodedata' = nodedata |> 
                setAt #m mass |>
                setAt #com [xbar, ybar]
            (Branch cnodes pnode nodedata')


' #### Estimate N-body forces

-- gravity = 6.674286e-11  -- units?
gravity = 6.67

def force (otherpos:Vec D) (othermass:Float) (pos:Vec D) : Vec D = 
    case otherpos == pos of
        True -> zero
        False -> 
            diff = otherpos - pos
            distance = sqrt $ vdot diff diff
            gf = gravity * othermass / (sq distance)
            gf .* diff / distance

def force' (nodedata:NodeData) (pos:Vec D) : Vec D = 
    mass = getAt #m nodedata
    com = getAt #com nodedata
    force com mass pos

def widthDistanceRatio (n:Node Body NodeData NodeId) (pos:Vec D) : Float = 
    nodedata = getNodeData n
    width = bbWidth $ getAt #bb nodedata
    diff = pos - (getAt #com nodedata)
    distance = sqrt $ vdot diff diff
    width/distance

def dequeue (q:List a) : (a&(List a)) = 
    (AsList _ arr) = q
    (head arr, tail arr 1)

def enqueue' (q:List NodeId) (cnodes:(Fin S)=>(Maybe NodeId)) : List NodeId = 
    q <> yieldAccum (ListMonoid NodeId) \l. for i.
        cnode = cnodes.i
        if (isJust cnode) 
            then append l (fromJust cnode)

-- API
def probe (tree:Tree Body NodeData NodeId) (theta:Float) (pos:Vec D) : Vec D = 
    (TreeArray _ arr) = tree
    initQueue = (AsList _ [0@_]) -- assume at least one node in tree
    yieldState zero \forceRef.
        withState initQueue \qRef.
            while \().
                (id, newq) = dequeue (get qRef)
                node = arr.id
                qRef := newq
                ratio = widthDistanceRatio node pos
                case ratio <= theta of
                    True -> -- long range force
                        nodedata = getNodeData node
                        forceRef := (get forceRef) + (force' nodedata pos)
                    False -> -- short range force
                        case node of 
                            Unused -> error "impossible to reach"
                            Leaf _ _ nodedata ->
                                forceRef := (get forceRef) + (force' nodedata pos)
                            Branch cnodes _ _ ->
                                qRef := enqueue' (get qRef) cnodes
                (listLength (get qRef) > 0)

def pairwiseProbe (bodies:BodyInd=>Body) (pos:Vec D) : Vec D= 
    yieldAccum (AddMonoid Float) \forceRef.
        for i. 
            body = bodies.i
            m = getAt #m body
            p = getAt #pos body
            forceRef += force p m pos

' ### Test

' #### Synthetic data

[k1,k2] = splitKey (newKey 0)
initPos : BodyInd=>Vec D = arb k1
masses  : BodyInd=>Float = one
bodies  : BodyInd=>Body  = for i. { ind=i, m=masses.i, pos=initPos.i, }

:p initPos
:p bodies

' #### Insert all elements

insertElement' = insertElement decide initNodeDataFn
updateAllNodeData' = updateAllNodeData updateBranchData

def buildTree (bodies:BodyInd=>Body) : Tree Body NodeData NodeId = 
    initTree = TreeArray (0@_) for i. Unused
    tree = yieldState initTree \t.
        for i. t:= insertElement' (get t) bodies.i
    updateAllNodeData' tree

%time
tree = buildTree bodies
:p tree


' #### Probing

' $\theta = 0.0$ makes sure that all leaves are reached

testPos1 = [1.0, 1.0]

%time
probe tree (0.0) testPos1

%time
pairwiseProbe bodies testPos1


' Increasing $\theta$ allows for faster but less accutate result

testPos2 = [10., 10.]

%time
probe tree (0.0) testPos2

%time
probe tree (0.2) testPos2

%time
probe tree (5.0) testPos2
