
' ## Barnes-Hut algorithm for the N body problem
https://jheer.github.io/barnes-hut/

' ### Quadtree

D = 2
S = intpow2 D

data Node a b node =
    Branch cnodes:((Fin S)=>(Maybe node))   pnode:(Maybe node)  nodedata:b
    Leaf   leafdata:a                       pnode:(Maybe node)  nodedata:b
    Unused

def Tree (a:Type) (b:Type) (node:Type) : Type = node => (Node a b node)

def replaceInTable [Eq n] (ind:n) (val:v) (vals:n=>v): n=>v = 
    yieldState vals \ref. ref!ind := val

def (+!) (n:a) (m:Int) : a = ((ordinal n) + m)@_

def isBranch (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> True
        Leaf _ _ _ -> False
        Unused -> False

def isLeaf (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> False
        Leaf _ _ _ -> True
        Unused -> False

def isUnused (n:Node a b node) : Bool = 
    case n of
        Branch _ _ _ -> False
        Leaf _ _ _ -> False
        Unused -> True

def getNodeData (n:Node a b node) : b = 
    case n of
        Branch _ _ nodedata -> nodedata
        Leaf _ _ nodedata -> nodedata
        Unused -> error "cannot get nodedata of unused node"

def extendLeaf1
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (leafid:node)
    (valsid:(Fin S))
    (val:a)
    : {State h} node =
    headId = get headIdref
    arr = get arrref
    (leafdata,leafpid,leafnodedata) = case arr.leafid of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> (replaceInTable valsid (Just headId))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    arrref!leafid := newbranch
    arrref!headId := newleaf
    headIdref := headId+!1
    headId

def extendLeaf2
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (leafid:node)
    (leafsid:(Fin S))
    (valsid:(Fin S))
    (val:a)
    : {State h} Unit =
    headId = get headIdref
    arr = get arrref
    (leafdata,leafpid,leafnodedata) = case arr.leafid of
        Leaf leafdata leafpid leafnodedata -> (leafdata,leafpid,leafnodedata)
    cnodes = (for _. Nothing) |> 
        (replaceInTable leafsid (Just headId)) |> 
        (replaceInTable valsid (Just (headId+!1)))
    newbranch = Branch cnodes leafpid leafnodedata
    newleaf = Leaf leafdata (Just leafid) (initNodeData newbranch leafdata)
    newval = Leaf val (Just leafid) (initNodeData newbranch val)
    arrref!leafid := newbranch
    arrref!headId := newleaf
    arrref!(headId+!1) := newval
    headIdref := headId+!2

def parentOfVal
    (decide:(Node a b node)->a->(Fin S)) 
    (arr:Tree a b node) 
    (val:a)
    : node = 
    yieldState (0@_) \cid.
        while \(). 
            cnode = arr.(get cid)
            case cnode of
                Unused -> False
                Leaf _ _ _ -> False
                Branch cnodes _ _ ->
                    ind = decide cnode val
                    case cnodes.ind of 
                        Just id -> 
                            cid := id
                            True
                        Nothing -> False

-- API
def insertElement
    (decide:(Node a b node)->a->(Fin S)) -- domain specific
    (initNodeData:(Node a b node)->a->b) -- domain specific
    (headIdref:Ref h node) (arrref:Ref h (Tree a b node))
    (val:a)
    : {State h} Unit =
    headId = get headIdref
    arr = get arrref
    -- find appropriate parent node (read only)
    pId:node = parentOfVal decide arr val
    -- modify the tree
    pnode = arr.pId
    case pnode of 
        Unused ->
            newleaf = Leaf val Nothing (initNodeData pnode val)
            arrref!pId := newleaf
            headIdref := headId+!1
        Branch cnodes ppnode bdata ->
            valsid = decide pnode val
            newcnodes = cnodes |> 
                (replaceInTable valsid (Just headId)) -- overwriting Nothing
            newbranch = Branch newcnodes ppnode bdata
            newleaf = Leaf val (Just pId) (initNodeData pnode val)
            arrref!pId := newbranch
            arrref!headId := newleaf
            headIdref := headId+!1
        Leaf pval _ _ ->
            -- uses pval and tree
            -- push this leaf down, until psid != valsid
            withState pId \leafidref.
                extendLeaf1' = extendLeaf1 initNodeData headIdref arrref
                extendLeaf2' = extendLeaf2 initNodeData headIdref arrref
                while \().
                    leafid = get leafidref
                    arr = get arrref
                    psid = decide arr.leafid pval
                    valsid = decide arr.leafid val
                    case psid == valsid of
                        True ->
                            leafidref := extendLeaf1' leafid valsid val
                            True
                        False -> 
                            extendLeaf2' leafid psid valsid val
                            False

-- todo this can be combined with insertElement in theory
-- pro: compute center of masses in one go
-- con: may complicate insertElement
-- API
def updateAllNodeData
    (updateBranchData:(Tree a b node)->(Node a b node)->(Node a b node))
    -- domain specific
    (arr:Tree a b node) : Tree a b node = 
    (AsList _ branchIds) = argFilter isBranch arr
    yieldState arr \ref. rof i.
        cbranch = get $ ref!(branchIds.i)
        ref!(branchIds.i) := updateBranchData (get ref) cbranch

' ### Domain specific setups

NodeId = Fin 20000
BodyInd = Fin 10000
def Vec (d:Int) : Type = (Fin d)=>Float
BBox = ((Vec D)&(Vec D))

Body = {
    ind:BodyInd
  & m:Float
  & pos:Vec D
--   & vel:Vec D
--   & nodeId:NodeId
}

NodeData = {
    bb:BBox
  & m:Float
  & com:Vec D
}

' #### Bounding box utilities

def bbWidth ((low, high):BBox) : Float =
    (high.(0@_) - low.(0@_))

def center ((low, high):BBox) : Vec D =
    half = (bbWidth (low, high)) / 2.
    for d. low.d + half

def subQuad ((low, high):BBox) (pos:Vec D) : Fin S =
    [mid_x, mid_y] = center (low, high)
    [pos_x, pos_y] = pos
    bit1 = BToW8 $ pos_x > mid_x
    bit2 = BToW8 $ pos_y > mid_y
    bits = W8ToI $ bit1 .|. (bit2 .<<. 1)
    bits@_

def subBox ((low, high):BBox) (pos:Vec D) : BBox =
    -- assume pos in BBox
    half = (bbWidth (low, high)) / 2.
    newlow = for d. low.d + half * (floor ((pos.d-low.d)/half))
    newhigh = for d. newlow.d + half
    (newlow, newhigh)

subBox ([0.5, 0.5], [1.0,1.0]) [0.51, 0.76]
subQuad ([0.5, 0.5], [1.0,1.0]) [0.51, 0.76]

' #### Two functions needed in insertElement

-- API
def initNodeDataFn (pnode:Node Body NodeData NodeId) (val:Body) : NodeData = 
    case pnode of 
        Unused -> 
            bbox = ([0., 0.], [1.,1.])
            pos = getAt #pos val
            { bb=bbox, m=(getAt #m val), com=pos }
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            bbox = subBox pbox pos
            { bb=bbox, m=(getAt #m val), com=pos }

-- API
def decide (pnode:Node Body NodeData NodeId) (val:Body) : (Fin S) = 
    case pnode of 
        Unused -> error "Function decide shouldn't be called on unused node"
        Leaf _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos
        Branch _ _ nodedata ->
            pbox = getAt #bb nodedata
            pos = getAt #pos val
            subQuad pbox pos


' #### One function needed in updateAllNodeData

def summarizeChildNodes
    (arr:Tree Body NodeData NodeId)
    (cnodes:(Fin S)=>(Maybe NodeId))
    : (Float & Float & Float) =
    [m, xmom, ymom] = yieldAccum (AddMonoid Float) \ref. 
        for i.
            cnode = cnodes.i
            case cnode of 
                Nothing -> ()
                Just id -> 
                    nodedata = getNodeData arr.id
                    m = getAt #m nodedata
                    [x,y] = getAt #com nodedata
                    ref += [m, x*m, y*m]
    (m, xmom/m, ymom/m)

-- API
def updateBranchData 
    (tree:Tree Body NodeData NodeId) 
    (bnode:Node Body NodeData NodeId)
    : Node Body NodeData NodeId = 
    case bnode of 
        Leaf _ _ _ -> error "shouldn't be called on leaves"
        Unused -> error "shouldn't be called on unused nodes"
        Branch cnodes pnode nodedata -> 
            (mass, xbar, ybar) = summarizeChildNodes tree cnodes
            nodedata' = nodedata |> 
                setAt #m mass |>
                setAt #com [xbar, ybar]
            (Branch cnodes pnode nodedata')


' #### Estimate N-body forces

-- gravity = 6.674286e-11  -- units?
gravity = 6.67

def force (otherpos:Vec D) (othermass:Float) (pos:Vec D) : Vec D = 
    case otherpos == pos of
        True -> zero
        False -> 
            diff = otherpos - pos
            distance = sqrt $ vdot diff diff
            gf = gravity * othermass / (sq distance)
            gf .* diff / distance

def force' (nodedata:NodeData) (pos:Vec D) : Vec D = 
    mass = getAt #m nodedata
    com = getAt #com nodedata
    force com mass pos

def widthDistanceRatio (n:Node Body NodeData NodeId) (pos:Vec D) : Float = 
    nodedata = getNodeData n
    width = bbWidth $ getAt #bb nodedata
    diff = pos - (getAt #com nodedata)
    distance = sqrt $ vdot diff diff
    width/distance

def dequeue (q:List a) : (a&(List a)) = 
    (AsList _ arr) = q
    (head arr, tail arr 1)

def enqueue' (q:List NodeId) (cnodes:(Fin S)=>(Maybe NodeId)) : List NodeId = 
    q <> yieldAccum (ListMonoid NodeId) \l. for i.
        cnode = cnodes.i
        if (isJust cnode) 
            then append l (fromJust cnode)

-- API
def probe (arr:Tree Body NodeData NodeId) (theta:Float) (pos:Vec D) : Vec D = 
    initQueue = (AsList _ [0@_]) -- assume at least one node in tree
    yieldState zero \forceRef.
        withState initQueue \qRef.
            while \().
                (id, newq) = dequeue (get qRef)
                node = arr.id
                qRef := newq
                ratio = widthDistanceRatio node pos
                case ratio <= theta of
                    True -> -- long range force
                        nodedata = getNodeData node
                        forceRef := (get forceRef) + (force' nodedata pos)
                    False -> -- short range force
                        case node of 
                            Unused -> error "impossible to reach"
                            Leaf _ _ nodedata ->
                                forceRef := (get forceRef) + (force' nodedata pos)
                            Branch cnodes _ _ ->
                                qRef := enqueue' (get qRef) cnodes
                (listLength (get qRef) > 0)

def pairwiseProbe (bodies:BodyInd=>Body) (pos:Vec D) : Vec D= 
    yieldAccum (AddMonoid Float) \forceRef.
        for i. 
            body = bodies.i
            m = getAt #m body
            p = getAt #pos body
            forceRef += force p m pos

' ### Test

' #### Synthetic data

[k1,k2] = splitKey (newKey 0)
initPos : BodyInd=>Vec D = for i j. rand $ ixkey2 k1 i j
masses  : BodyInd=>Float = one
bodies  : BodyInd=>Body  = for i. { ind=i, m=masses.i, pos=initPos.i, }

-- :p initPos
-- :p bodies

' #### Insert all elements

def buildTree (bodies:BodyInd=>Body) : Tree Body NodeData NodeId = 
    inithead = 0@NodeId
    initarr  = for i. Unused
    (_, tree) = yieldState (inithead, initarr) \ref.
        insertElement' = insertElement decide initNodeDataFn (fstRef ref) (sndRef ref)
        for i. insertElement' bodies.i
    updateAllNodeData' = updateAllNodeData updateBranchData
    updateAllNodeData' tree

%time
tree = buildTree bodies
-- :p tree

depths = 
    (AsList _ leaves) = argFilter isLeaf tree
    unsafeCastTable BodyInd for i.
        yieldState (-1) \count.
            withState (Just leaves.i) \nref.
                while \().

                    case (get nref) of
                        Just node -> 
                            pnode = case tree.node of
                                Leaf _ pnode _ -> pnode
                                Branch _ pnode _ -> pnode
                            nref := pnode
                            count := (get count) + 1
                            True
                        Nothing -> False

:t depths

:p minimum depths

:p maximum depths

:p mean $ map IToF depths

:p std $ map IToF depths


import plot
[x,y] = transpose initPos
:html showPlot $ xyPlot x y

' #### Probing

' $\theta = 0.0$ makes sure that all leaves are reached

testPos1 = [1.0, 1.0]

%time
probe tree (0.0) testPos1

%time
pairwiseProbe bodies testPos1


' Increasing $\theta$ allows for faster but less accutate result

testPos2 = [10., 10.]

%time
probe tree (0.0) testPos2

%time
probe tree (0.2) testPos2

%time
probe tree (5.0) testPos2

' Is BH faster than bruteforce? 
Yes, only when body number > 40000

%time
forces1 = for i. probe tree (1.0) initPos.i

%time
forces2 = for i. pairwiseProbe bodies initPos.i

loss = mean for i.
    diff = forces1.i - forces2.i
    sum $ map abs diff

:p loss
