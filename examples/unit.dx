' https://www.stephanboyer.com/post/131/type-safe-dimensional-analysis-in-haskell 

-- wrapper type around Float, a keeps track of the unit
data BaseQuantity a = 
    MkBaseQuantity Float
DimensionlessQuantity = BaseQuantity Unit

Quotient = \a b. b->a -- a/b
Inverse = Quotient DimensionlessQuantity
Product = \a b. Quotient a (Inverse b)
Square  = \a. Product a a

interface Quantity q
    construct : Float -> q
    destruct  : q -> Float

instance Quantity (BaseQuantity a)
    construct = MkBaseQuantity
    destruct  = \(MkBaseQuantity x). x

instance [Quantity q, Quantity r] Quantity (Quotient r q)
    construct = \x:Float. \y. construct (x*(destruct y))
    destruct  = \x:(Quotient r q). destruct (x (construct 1.0))

def quotientAxiom [Quantity a, Quantity b, Quantity c] 
    (_ : Quotient a (Quotient b c)) : Quotient c (Quotient b a)
    = construct <<< destruct

instance [Quantity a] Add a
    add = \x y. construct $ (destruct x) + (destruct y)
    sub = \x y. construct $ (destruct x) - (destruct y)
    zero = construct 0.

-- mimic Mul interface
def mul' [Quantity a, Quantity b] (x:a) (y:b) : Product a b = 
    \z. construct $ destruct (z y) * destruct x

def one' [Quantity a] : a = construct 1.

-- mimic Fractional interface
def divide' [Quantity a, Quantity b] (x:a) (y:b) : Quotient a b = 
    \z. construct $ (destruct z) * (destruct x) / (destruct y)

def (+!) [Quantity a] : a->a->a = add
def (-!) [Quantity a] : a->a->a = sub
def (*!) [Quantity a, Quantity b] : a->b->(Product a b) = mul'
def (/!) [Quantity a, Quantity b] : a->b->(Quotient a b) = divide'

instance [Quantity a] Eq a
    (==) = \x y. (destruct x) == (destruct y)

instance [Quantity a] Ord a
    (>) = \x y. (destruct x) > (destruct y)
    (<) = \x y. (destruct x) < (destruct y)

' Examples

data Meter = MkMeter -- dummy constructors
data Kilogram = MkKilogram
data Second = MkSecond

Length = BaseQuantity Meter
Mass = BaseQuantity Kilogram
Time = BaseQuantity Second
Area = Square Length
Velocity = Quotient Length Time

:p Length
:p Velocity

l1 : Length = construct 1.0
:t l1
:t destruct l1
