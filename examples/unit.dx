' ## Type safe dimensional analysis in Dex
Reimplementing [Type safe dimensional analysis in Haskell by Stepan Boyer](https://www.stephanboyer.com/post/131/type-safe-dimensional-analysis-in-haskell) 

' #### Define the quantity interface

-- wrap around Float to track the unit
data BaseQuantity a = 
    MkBaseQuantity Float
DimensionlessQuantity = BaseQuantity Unit

Quotient = \a b. b->a -- a/b
Inverse = Quotient DimensionlessQuantity
Product = \a b. Quotient a (Inverse b)
Square  = \a. Product a a

interface Quantity q
    construct : Float -> q
    destruct  : q -> Float

instance Quantity (BaseQuantity a)
    construct = MkBaseQuantity
    destruct  = \(MkBaseQuantity x). x

instance [Quantity q, Quantity r] Quantity (Quotient r q)
    construct = \x:Float. \y. construct (x*(destruct y))
    destruct  = \x:(Quotient r q). destruct (x (construct 1.0))

' #### Algebra with quantities

instance [Quantity a] Add a
    add = \x y. construct $ (destruct x) + (destruct y)
    sub = \x y. construct $ (destruct x) - (destruct y)
    zero = construct 0.

-- cannot implement the Mul interface as the types do not match.
def mul' [Quantity a, Quantity b] (x:a) (y:b) : Product a b = 
    \z. construct $ destruct (z y) * destruct x

def one' [Quantity a] : a = construct 1.

def divide' [Quantity a, Quantity b] (x:a) (y:b) : Quotient a b = 
    \z. construct $ (destruct z) * (destruct x) / (destruct y)

def quotientAxiom [Quantity a, Quantity b, Quantity c] : 
    (Quotient a (Quotient b c)) -> (Quotient c (Quotient b a))
    = destruct >>> construct

def (+!) [Quantity a] : a->a->a = add
def (-!) [Quantity a] : a->a->a = sub
def (*!) [Quantity a, Quantity b] : a->b->(Product a b) = mul'
def (/!) [Quantity a, Quantity b] : a->b->(Quotient a b) = divide'

instance [Quantity a] Eq a
    (==) = \x y. (destruct x) == (destruct y)

instance [Quantity a] Ord a
    (>) = \x y. (destruct x) > (destruct y)
    (<) = \x y. (destruct x) < (destruct y)

instance [Quantity a] Arbitrary a
    arb = \key. construct $ arb key

def qcast [Quantity q, Quantity r] : q->r = destruct >>> construct

' #### Examples

data Meter = MkMeter -- dummy constructors
data Kilogram = MkKilogram
data Second = MkSecond

Length = BaseQuantity Meter
Mass = BaseQuantity Kilogram
Time = BaseQuantity Second

instance Show Length
    show = \(MkBaseQuantity t). (show t) <> " m"

instance Show Mass
    show = \(MkBaseQuantity t). (show t) <> " kg"

instance Show Time
    show = \(MkBaseQuantity t). (show t) <> " sec"

Area = Square Length
Velocity = Quotient Length Time

instance [Show a, Show b] Show (Quotient a b)
    show = todo

:p Length
:p Velocity

' Example 1: track units in types

width  : Length = construct 1.5
height : Length = construct 2.5
area   : Area   = width *! height

:p (destruct area)
:t area
-- :p (show area)

mass   : Mass   = construct 150.
-- expect type error
area2  : Area   = width *! mass

' Example 2: quantities as functions

velocity : Velocity = construct 30.    -- m/s
duration : Time     = construct 5000.  -- s
distance : Length   = velocity duration-- m
-- (m/s) * (s) = (m), cancel the denominator with function application
:p (destruct distance)
:t distance
:p (show distance)
-- distance2 : Length   = duration velocity -- breaks

' Example 3: manual proof of unit equality

def calculateDuration (dist:Length) (vel:Velocity) : Time = 
    (quotientAxiom (dist /! vel)) id

fasterVelocity : Velocity = construct 40.
shorterDuration: Time = calculateDuration distance fasterVelocity

:p (destruct shorterDuration)
:t shorterDuration
:p (show shorterDuration)

' Example 4: bounded real numbers

' A more efficient way is newtype (see mcmc.dx LogProb=Float)

data UnboundedFloat = MkUnbounded
data NormalizedFloat = MkNormalized
data PositiveFloat = MkPositive
data NonNegativeFloat = MkNonNegative

Unbounded = BaseQuantity UnboundedFloat
Probability = BaseQuantity NormalizedFloat
ProbDensity = BaseQuantity NonNegativeFloat
LogProbDensity = BaseQuantity UnboundedFloat

instance Show Unbounded
    show = \(MkBaseQuantity x). (show x) <> "from (-inf, +inf)"
instance Show Probability
    show = \(MkBaseQuantity x). (show x) <> "from [0, 1]"
instance Show ProbDensity
    show = \(MkBaseQuantity x). (show x) <> "from [0, +inf)"
instance Show LogProbDensity
    show = \(MkBaseQuantity x). (show x) <> "from (-inf, +inf)"

-- continuous probability distribution
def qfromFloat [Quantity q] : Float -> q = construct

def qtoFloat [Quantity q] : q -> Float = destruct

def qapply [Quantity q, Quantity r] (f:Float->Float) : q->r =
    destruct >>> f >>> construct

def qexp : LogProbDensity -> ProbDensity = qapply exp

def qlog : ProbDensity -> LogProbDensity = qapply log

def qnormalizePdf (qxs:n=>Unbounded) : n=>ProbDensity =
    xs = map destruct qxs
    ret = xs / sum xs
    map construct ret

def qsoftmax (qxs:n=>Unbounded) : n=>Probability =
    xs = map destruct qxs
    ret = softmax xs
    map construct ret

def qlogsoftmax (qxs:n=>Unbounded) : n=>LogProbDensity =
    xs = map destruct qxs
    ret = logsoftmax xs
    map construct ret

-- discrete probability distribution
def qcumSumLow (qxs:n=>Probability) : n=>Probability =
    xs = map destruct qxs
    ret = cumSumLow xs
    map construct ret

x : (Fin 5)=>Float = arb (newKey 0)
:t x

qx : (Fin 5)=>Unbounded = map qfromFloat x
:p qx
:t qx

normalized_qx = qsoftmax qx
:p normalized_qx
:t normalized_qx

normalized_x = map qtoFloat normalized_qx
:t normalized_x

' #### Future directions
- extend units to Floating operations e.g. log(x)
- enable: the determinant of a matrix is volumetric
