' ### Gaussian Process Regression

import linalg

def chol_solve (l:LowerTriMat n Float) (b:n=>Float) : n=>Float = 
    b' = forward_substitute l b
    u = transposeLowerToUpper l
    backward_substitute u b'

def gaussian_kernel (variance:Float) 
    (x:d=>Float) (z:d=>Float) : Float = 
    diff = x - z
    power = neg (vdot diff diff) / variance / 2.
    exp power

def gp_prediction 
    (xs1:n1=>d=>Float) (ys1:n1=>Float) (xs2:n2=>d=>Float)
    (kernel:(d=>Float)->(d=>Float)->Float) (noise_var:Float)
    : (n2=>Float & n2=>n2=>Float) = 
    k11 = for i j. kernel xs1.i xs1.j
    k21 = for i j. kernel xs2.i xs1.j
    k22 = for i j. kernel xs2.i xs2.j
    c = chol $ k11 + noise_var .* eye
    mu_pred = k21 **. (chol_solve c ys1)
    temp:n1=>n2=>Float = transpose for i. chol_solve c k21.i
    cov_pred = k22 + (noise_var .* eye) - (k21 ** temp)
    (mu_pred, cov_pred)

' Test

import plot

arr1 = linspace (Fin 11) (-3.) (3.6)
xs1 = for i. [arr1.i]   -- training
ys1 = for i. sin arr1.i + 0.1 .* arb (newKey 0)

arr2 = linspace (Fin 201) (-5.) (5.05)
xs2 = for i. [arr2.i]   -- test
-- ys2 = for i. sin arr2.i -- target

noise_var = pow 0.1 2.0

(ys2_mu, ys2_cov) = gp_prediction xs1 ys1 xs2 (gaussian_kernel 1.0) noise_var

ys2_std = for i. sqrt ys2_cov.i.i
ys2_upper = ys2_mu + ys2_std
ys2_lower = ys2_mu - ys2_std

p_base = xycPlot arr2 ys2_mu ys2_std
p_lower = xyPlot arr2 ys2_lower
p_upper = xyPlot arr2 ys2_upper

def showDiagram (d:Diagram) : String =
  renderSVG d ((0.0, 0.0), (1.0, 1.0))

:html showDiagram $ (plotToDiagram p_base) <> 
  (plotToDiagram p_lower) <> 
  (plotToDiagram p_upper)
