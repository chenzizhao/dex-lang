' ### Gaussian Process Regression
Similar to examples/kernelregression.dx but this demo uses GP and chol_solve from linalg instead of a gradient solver.

import linalg
import plot

def chol_solve (l:LowerTriMat n Float) (b:n=>Float) : n=>Float = 
    b' = forward_substitute l b
    u = transposeLowerToUpper l
    backward_substitute u b'

def gp_regress (kernel: a -> a -> Float) (xs: n=>a) (ys: n=>Float)
    : (a -> (Float&Float)) =
    noise_var = 0.0001
    gram = for i j. kernel xs.i xs.j
    c = chol (gram + eye *. noise_var)
    alpha = chol_solve c ys
    predict = \x.
        k' = for i. kernel xs.i x
        mu = sum for i. alpha.i * k'.i
        alpha' = chol_solve c k'
        var = kernel x x + noise_var - sum for i. k'.i * alpha'.i
        (mu, var)
    predict

def rbf (lengthscale:Float) (x:Float) (y:Float) : Float =
    exp (-0.5 * sq ((x - y) / lengthscale))

' Test: same as examples/kernelregression.dx

-- Synthetic data
Nx = Fin 100
noise = 0.1
[k1, k2] = splitKey (newKey 0)

def trueFun (x:Float) : Float =
    x + sin (20.0 * x)

xs : Nx=>Float = for i. rand (ixkey k1 i)
ys : Nx=>Float = for i. trueFun xs.i + noise * randn (ixkey k2 i)

predict = gp_regress (rbf 0.2) xs ys

-- Evaluation
Nxtest = Fin 1000
xtest : Nxtest=>Float = for i. rand (ixkey k1 i)
(preds, vars) = unzip (map predict xtest)

:html showPlot $ xyPlot xs ys
> <html output>

:html showPlot $ xycPlot xtest preds (map sqrt vars)
> <html output>

:html showPlot $ xyPlot xtest vars
> <html output>
