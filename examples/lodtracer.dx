
import plot

'## General Utilies

def length    (x: d=>Float) : Float = sqrt $ sum for i. sq x.i

def pngsToSavedGif (delay:Int) (pngs:t=>Png) (outFileName:String) : Gif =
  unsafeIO \().
    withTempFiles \pngFiles.
      for i.
        writeFile pngFiles.i pngs.i
      shellOut $
        "convert" <> " -delay " <> show delay <> " " <>
        concat (for i. "png:" <> pngFiles.i <> " ") <>
        "gif:" <> outFileName <> ".gif"


def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : (Fin 3)=>Float =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]


def W8ToB' (x : Word8) : Bool = x > (IToW8 0)  -- Bug in prelude

def firstbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 1)
def secondbit (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 2)
def thirdbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 4)

def ixFraction (i:n) : Float = (IToF (ordinal i)) / (IToF ((size n) - 1))


'## Types

def Vec (n:Int) : Type = Fin n => Float

Position  = Vec 3
Direction = Vec 3  -- Should be normalized. TODO: use a newtype wrapper
Distance = Float

Ray = (Position & Direction)

Octant = Fin 8 -- (Bool & Bool & Bool)  -- positive in x, y, or z

LoD = Int
max_lod = 6

-- czz: why doesn't this work? 
-- def Voxel (numDivisions:Int) : Type =
--  (Fin numDivisions & Fin numDivisions & Fin numDivisions)

def Voxel : Type =
  (Int & Int & Int & LoD)  -- Sad!

def AABox : Type = (Position & Position)  -- opposite corners


'## Bounding box utilities

def voxelWidth (lod: LoD) : Float = 
  -- voxels divide up cube in (-1, 1)
  numDivisions = intpow2 lod
  2.0 / (IToF numDivisions)

def voxelToCentrePosition (voxel: Voxel) : Position =
  (xn, yn, zn, lod) = voxel
  divSize = voxelWidth lod
  [divSize * (0.5 + IToF xn) - 1.0,
   divSize * (0.5 + IToF yn) - 1.0,
   divSize * (0.5 + IToF zn) - 1.0]

def voxeltoBB (voxel: Voxel) : AABox =
  (xn, yn, zn, lod) = voxel
  divSize = voxelWidth lod
  lower = [divSize * (IToF xn) - 1.0,
           divSize * (IToF yn) - 1.0,
           divSize * (IToF zn) - 1.0]
  upper = [divSize * (IToF (xn + 1)) - 1.0,
           divSize * (IToF (yn + 1)) - 1.0,
           divSize * (IToF (zn + 1)) - 1.0]
  (lower, upper)

def rayAABBIntersectionHelper (ray:Ray) (box:AABox) : (Float & Float) =
  ([pos_x, pos_y, pos_z], [dir_x,  dir_y,  dir_z ]) = ray
  ([low_x, low_y, low_z], [high_x, high_y, high_z]) = box
  (tx1, tx2) = ((low_x - pos_x) / dir_x, (high_x - pos_x) / dir_x)
  (ty1, ty2) = ((low_y - pos_y) / dir_y, (high_y - pos_y) / dir_y)
  (tz1, tz2) = ((low_z - pos_z) / dir_z, (high_z - pos_z) / dir_z)
  (txn, txf) = min_and_max tx1 tx2
  (tyn, tyf) = min_and_max ty1 ty2
  (tzn, tzf) = min_and_max tz1 tz2
  tnear = max txn $ max tyn tzn
  tfar  = min txf $ min tyf tzf
  (tfar, tnear)

def rayAABBIntersection (ray:Ray) (box:AABox) : Bool =
  (tfar, tnear) = rayAABBIntersectionHelper ray box
  tfar > tnear && tfar > 0.0

def rayAABBIntersectionDistance (ray:Ray) (box:AABox) : Distance = 
  (_, tnear) = rayAABBIntersectionHelper ray box
  (_, ray_dir) = ray
  tnear * (length ray_dir)

def intersectsVoxel (ray:Ray) (voxel: Voxel) : Bool =
  box = voxeltoBB voxel
  rayAABBIntersection ray box

def intersectsVoxelDistance (ray:Ray) (voxel: Voxel) : Distance =
  box = voxeltoBB voxel
  rayAABBIntersectionDistance ray box

'## Octtree intersection

octantBackToFrontTable : Octant=>Octant=>Octant =
  intTable = [[ 0, 1, 2, 4, 3, 5, 6, 7 ],
              [ 1, 0, 3, 5, 2, 4, 7, 6 ],
              [ 2, 0, 3, 6, 1, 4, 7, 5 ],
              [ 3, 1, 2, 7, 0, 5, 6, 4 ],
              [ 4, 0, 5, 6, 1, 2, 7, 3 ],
              [ 5, 1, 4, 7, 0, 3, 6, 2 ],
              [ 6, 2, 4, 7, 0, 3, 5, 1 ],
              [ 7, 3, 5, 6, 1, 2, 4, 0 ]]
  for i j. (intTable.i.j@Octant)

def childOctantToSubVoxel (voxel: Voxel) (oct:Octant) : Voxel =
  oo = IToW8 $ ordinal oct
  (x, y, z, lod) = voxel
  (2 * x + (BToI $ firstbit oo),
   2 * y + (BToI $ secondbit oo),
   2 * z + (BToI $ thirdbit oo),
   lod+1)

def subVoxelPosToChildOctant (voxel: Voxel) (pos:Position) : Octant =
  [mid_x, mid_y, mid_z] = voxelToCentrePosition voxel
  [pos_x, pos_y, pos_z] = pos 
  bit1 = BToW8 $ pos_x > mid_x
  bit2 = BToW8 $ pos_y > mid_y
  bit3 = BToW8 $ pos_z > mid_z
  bits = W8ToI $ bit1 .|. (bit2 << 1) .|. (bit3 << 2)
  bits@Octant

def orderedChildren (ray:Ray) (voxel: Voxel) : List Octant =
  (pos, dir) = ray
  oct = subVoxelPosToChildOctant voxel pos
  childOctants = octantBackToFrontTable oct
  yieldAccum (ListMonoid Octant) \list.
    for t.
      subVoxel = childOctantToSubVoxel voxel childOctants.t
      if intersectsVoxel ray subVoxel then
        list += AsList 1 [childOctants.t]

def subdivide (ray:Ray) ((AsList _ voxels) : List Voxel) : List Voxel =
  -- Returned voxels are of the next level of detail.
  -- Todo: Encode this in the types.
  yieldAccum (ListMonoid Voxel) \list.
    for t.
      (AsList _ childOcts) = orderedChildren ray voxels.t
      list += AsList _ for i. childOctantToSubVoxel voxels.t childOcts.i

top_voxel : Voxel = (0, 0, 0, 0) -- todo: put it somewhere else

def rayTraceOctTree (ray:Ray) : List Voxel = 
  init = AsList 1 [top_voxel]
  yieldState init \ls_ref.
    for _:(Fin max_lod).
      ls_ref := subdivide ray (get ls_ref)

def test_sdf (pos:Position):Distance =
  -- return 0.0 if pos is on a sphere, 
  -- negative number if pos in sphere, 
  -- positive number if pos outside sphere
  sphereOrigin : Position = [0.03,(-0.05),(0.01)]
  sphereRadius : Float = 0.05
  pos' : Position = pos - sphereOrigin
  max (length pos' - sphereRadius) 0.0
  
def sdfWrap (lod:LoD) (pos:Position) : Distance =
  -- input = concat' pos (posToFeature pos lod) 
  -- -- concat' should be the version with cast.
  -- wnb = wnb_sgds.((lod-1)@_) -- use appropriate WnB
  -- -- wnb_sgds is also a global cache / trained in nglod.dx
  -- mlp input wnb
  test_sdf pos

-- @noinline -- not impl'ed Imp654
def voxelContainsSurface (voxel:Voxel) (ray:Ray) (sdf:Position->Distance) : Bool = 
  d = sdf (voxelToCentrePosition voxel)
  (_,_,_,lod) = voxel
  w = voxelWidth lod
  (abs d < (sqrt(3.) * w /2.))

-- @noinline -- should't be compiling ptr literals src/lib/JIT.hs: 683
def rayTraceOctTreeSparse (ray:Ray) : List Voxel = 
  (AsList _ voxels) = rayTraceOctTree ray
  sdf = sdfWrap max_lod
  condition = \v. voxelContainsSurface v ray sdf
  filter condition voxels

-- @noinline -- not impl'ed Imp654
def inVoxelList (vCurr:Voxel) ((AsList n vs) : List Voxel) : Bool = 
  anySat ((==) vCurr) vs

def isStrictAfter (v1:Voxel) ((_, rayDir) : Ray) (v2:Voxel) : Bool = 
  -- assume both v1 and v2 are intersected by ray
  -- return True if v2 is after v1
  --       False if overlaps or v2 is before v1
  (x1, y1, z1, _) = v1
  (x2, y2, z2, _) = v2
  pos1 = map IToF [x1, y1, z1]
  pos2 = map IToF [x2, y2, z2]
  vDir = pos2 - pos1
  (vdot vDir rayDir) > 0.

invalid_voxel : Voxel = (0,0,0,(-1))
outside_root_voxel : Voxel = (0,0,0,(-2))

def nextVoxelInDepthOrderedList (vCurr:Voxel) ((AsList n vs):List Voxel) (ray:Ray) : Voxel =
  if n == 0
    then invalid_voxel
    else 
      if vCurr == outside_root_voxel
        then head vs
        else
          condition = isStrictAfter vCurr ray
          (AsList nInds inds) = argFilter condition vs
          if nInds == 0
            then invalid_voxel
            else vs.(head inds)



@noinline
def posInRootVoxel (pos:Position) : Bool = 
  pos.(0@_) <= 1.0 && pos.(0@_) >= (-1.0) && pos.(1@_) <= 1.0 && pos.(1@_) >= (-1.0) && pos.(2@_) <= 1.0 && pos.(2@_) >= (-1.0) 
  -- all for d. pos.d <= 1.0 && pos.d >= (-1.0) -- this doesn't work BUG?

def leafVoxel (pos:Position) : Voxel = 
  case posInRootVoxel pos of
    False -> outside_root_voxel
    True -> 
      lods = max_lod + 1
      update = \ _:(Fin lods) v:Voxel.
        childOct = subVoxelPosToChildOctant v pos
        childOctantToSubVoxel v childOct
      fold top_voxel update



---- Tests

:p rayAABBIntersection ([0., 0., 0.], [0.1, 0.1, 0.1]) ([-0.1, -0.1, -0.1], [0.1, 0.1, 0.1])

:p leafVoxel [0.1, 0.1, 0.1]


'## Raytracer for debugging

def relu (x:Float) : Float = max x 0.0
def normalize (x: d=>Float) : d=>Float = x / (length x)
def directionAndLength (x: d=>Float) : (d=>Float & Float) =
  l = length x
  (x / (length x), l)

-- move this somewhere else
xHat : Vec 3 = [1., 0., 0.]
yHat : Vec 3 = [0., 1., 0.]
zHat : Vec 3 = [0., 0., 1.]

RayC = (Ray & (List Voxel))


-- Assumes we're looking towards -z.
Camera =
  { numPix     : Int
  & pos        : Position  -- pinhole position
  & halfWidth  : Float     -- sensor half-width
  & sensorDist : Float }   -- pinhole-sensor distance

-- TODO: might be better with an anonymous dependent pair for the result
def cameraRays (camera:Camera) : Fin n => Fin n => RayC =
  -- images indexed from top-left
  -- n = getAt #numPix camera
  halfWidth = getAt #halfWidth camera
  pixHalfWidth = halfWidth / IToF n
  ys = reverse $ linspace (Fin n) (neg halfWidth) halfWidth
  xs =           linspace (Fin n) (neg halfWidth) halfWidth
  for i j.
    x = xs.j
    y = ys.i
    rayPos = getAt #pos camera
    rayDir = normalize [x, y, neg (getAt #sensorDist camera)]
    ray = (rayPos, rayDir)
    rayList = rayTraceOctTreeSparse ray
    (ray, rayList)

posInf = (1.0/0.0)


def sdAdaptive (rayPos:Position) ((ray, rayList):RayC)
  : Distance = 
  (rayOrigin, rayDir) = ray
  posVoxel = leafVoxel rayPos
  if inVoxelList posVoxel rayList
    then (sdfWrap max_lod rayPos)*0.9
    else
      nextVoxel = nextVoxelInDepthOrderedList posVoxel rayList ray 
      if nextVoxel == invalid_voxel
        then posInf
        -- todo prevvoxel
        else (intersectsVoxelDistance (rayPos, rayDir) nextVoxel)+0.001

def adaptiveSphereTrace (rayC:RayC) : Color = 
  maxIters = 100
  tolerance = 0.001
  (ray, rayList) = rayC
  (rayOrigin, rayDir) = ray
  (AsList vn vs) = rayList
  withState (0.01)\(rayLength).
    boundedIter maxIters zero \_.
      rayPos = rayOrigin + get rayLength .* rayDir
      d = sdAdaptive rayPos rayC
      rayLength := get rayLength + d
      case d == posInf of 
        True -> Done zero
        False -> 
          case d > tolerance of 
            True -> Continue
            False -> 
              -- surfNorm = calcNormalImplicit rayPos rayC -- todo
              h = (get rayLength) * 20.
              surfNorm = hslToRgb h 1.0 0.5
              Done $ surfNorm

' ### Define the scene and render it

defaultCamera = { numPix     = 100 -- 400
                , pos        = 1.0 .* zHat
                , halfWidth  = 0.3
                , sensorDist = 1.5 }

%time
rayvoxels : (Fin 100)=>(Fin 100)=>RayC = cameraRays defaultCamera

%time
canvas = for i j. adaptiveSphereTrace rayvoxels.i.j

:html imshow canvas
