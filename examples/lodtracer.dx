
import plot

'## General Utilies

def length    (x: d=>Float) : Float = sqrt $ sum for i. sq x.i

def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : (Fin 3)=>Float =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]


def W8ToB' (x : Word8) : Bool = x > (IToW8 0)  -- Bug in prelude

def firstbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 1)
def secondbit (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 2)
def thirdbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 4)

'## Types

def Vec (n:Int) : Type = Fin n => Float
Position  = Vec 3
Direction = Vec 3  -- Should be normalized. TODO: use a newtype wrapper
Distance = Float
Ray = (Position & Direction)
Octant = Fin 8 -- (Bool & Bool & Bool)  -- positive in x, y, or z

LoD = Int
max_lod = 5

def Voxel : Type = (Int & Int & Int & LoD)  -- Sad!
top_voxel : Voxel = (0,0,0,0) -- todo: put it somewhere else
invalid_voxel : Voxel = (0,0,0,(-1))
outside_root_voxel : Voxel = (0,0,0,(-2))

def AABox : Type = (Position & Position)  -- opposite corners

'## Bounding box utilities

def voxelWidth (lod: LoD) : Float = 
  -- voxels divide up cube in (-1, 1)
  numDivisions = intpow2 lod
  2.0 / (IToF numDivisions)

def voxelToCentrePosition (voxel: Voxel) : Position =
  (xn, yn, zn, lod) = voxel
  divSize = voxelWidth lod
  [divSize * (0.5 + IToF xn) - 1.0,
   divSize * (0.5 + IToF yn) - 1.0,
   divSize * (0.5 + IToF zn) - 1.0]

def voxeltoBB (voxel: Voxel) : AABox =
  (xn, yn, zn, lod) = voxel
  divSize = voxelWidth lod
  lower = [divSize * (IToF xn) - 1.0,
           divSize * (IToF yn) - 1.0,
           divSize * (IToF zn) - 1.0]
  upper = [divSize * (IToF (xn + 1)) - 1.0,
           divSize * (IToF (yn + 1)) - 1.0,
           divSize * (IToF (zn + 1)) - 1.0]
  (lower, upper)

def rayAABBIntersectionHelper (ray:Ray) (box:AABox) : (Float & Float) =
  ([pos_x, pos_y, pos_z], [dir_x,  dir_y,  dir_z ]) = ray
  ([low_x, low_y, low_z], [high_x, high_y, high_z]) = box
  (tx1, tx2) = ((low_x - pos_x) / dir_x, (high_x - pos_x) / dir_x)
  (ty1, ty2) = ((low_y - pos_y) / dir_y, (high_y - pos_y) / dir_y)
  (tz1, tz2) = ((low_z - pos_z) / dir_z, (high_z - pos_z) / dir_z)
  (txn, txf) = min_and_max tx1 tx2
  (tyn, tyf) = min_and_max ty1 ty2
  (tzn, tzf) = min_and_max tz1 tz2
  tnear = max txn $ max tyn tzn
  tfar  = min txf $ min tyf tzf
  (tfar, tnear)

def rayAABBIntersection (ray:Ray) (box:AABox) : Bool =
  (tfar, tnear) = rayAABBIntersectionHelper ray box
  tfar > tnear && tfar > 0.0

def rayAABBIntersectionDistance (ray:Ray) (box:AABox) : Distance = 
  (_, tnear) = rayAABBIntersectionHelper ray box
  (_, ray_dir) = ray
  tnear * (length ray_dir)

def intersectsVoxel (ray:Ray) (voxel: Voxel) : Bool =
  box = voxeltoBB voxel
  rayAABBIntersection ray box

def intersectsVoxelDistance (ray:Ray) (voxel: Voxel) : Distance =
  box = voxeltoBB voxel
  rayAABBIntersectionDistance ray box

'## Octtree intersection

octantBackToFrontTable : Octant=>Octant=>Octant =
  intTable = [[ 0, 1, 2, 4, 3, 5, 6, 7 ],
              [ 1, 0, 3, 5, 2, 4, 7, 6 ],
              [ 2, 0, 3, 6, 1, 4, 7, 5 ],
              [ 3, 1, 2, 7, 0, 5, 6, 4 ],
              [ 4, 0, 5, 6, 1, 2, 7, 3 ],
              [ 5, 1, 4, 7, 0, 3, 6, 2 ],
              [ 6, 2, 4, 7, 0, 3, 5, 1 ],
              [ 7, 3, 5, 6, 1, 2, 4, 0 ]]
  for i j. (intTable.i.j@Octant)

def childOctantToSubVoxel (voxel: Voxel) (oct:Octant) : Voxel =
  oo = IToW8 $ ordinal oct
  (x, y, z, lod) = voxel
  (2 * x + (BToI $ firstbit oo),
   2 * y + (BToI $ secondbit oo),
   2 * z + (BToI $ thirdbit oo),
   lod+1)

def subVoxelPosToChildOctant (voxel: Voxel) (pos:Position) : Octant =
  [mid_x, mid_y, mid_z] = voxelToCentrePosition voxel
  [pos_x, pos_y, pos_z] = pos 
  bit1 = BToW8 $ pos_x > mid_x
  bit2 = BToW8 $ pos_y > mid_y
  bit3 = BToW8 $ pos_z > mid_z
  bits = W8ToI $ bit1 .|. (bit2 << 1) .|. (bit3 << 2)
  bits@Octant

def orderedChildren (ray:Ray) (voxel: Voxel) : List Octant =
  (pos, dir) = ray
  oct = subVoxelPosToChildOctant voxel pos
  childOctants = octantBackToFrontTable oct
  yieldAccum (ListMonoid Octant) \list.
    for t.
      subVoxel = childOctantToSubVoxel voxel childOctants.t
      if intersectsVoxel ray subVoxel then
        list += AsList 1 [childOctants.t]

def subdivide (ray:Ray) ((AsList _ voxels) : List Voxel) : List Voxel =
  -- Returned voxels are of the next level of detail.
  -- Todo: Encode this in the types.
  yieldAccum (ListMonoid Voxel) \list.
    for t.
      (AsList _ childOcts) = orderedChildren ray voxels.t
      list += AsList _ for i. childOctantToSubVoxel voxels.t childOcts.i

def rayTraceOctTree (ray:Ray) : List Voxel = 
  init = AsList 1 [top_voxel]
  yieldState init \ls_ref.
    for _:(Fin max_lod).
      ls_ref := subdivide ray (get ls_ref)

def test_sdf (pos:Position):Distance =
  -- return 0.0 if pos is on a sphere, 
  -- negative number if pos in sphere, 
  -- positive number if pos outside sphere
  sphereOrigin : Position = [0.03,(-0.05),(0.01)]
  sphereRadius : Float = 0.05
  pos' : Position = pos - sphereOrigin
  max (length pos' - sphereRadius) 0.0
  
def sdfWrap (lod:LoD) (pos:Position) : Distance =
  -- input = concat' pos (posToFeature pos lod) 
  -- -- concat' should be the version with cast.
  -- wnb = wnb_sgds.((lod-1)@_) -- use appropriate WnB
  -- -- wnb_sgds is also a global cache / trained in nglod.dx
  -- mlp input wnb
  test_sdf pos

-- @noinline -- not impl'ed Imp654
def voxelContainsSurface (voxel:Voxel) (ray:Ray) (sdf:Position->Distance) : Bool = 
  d = sdf (voxelToCentrePosition voxel)
  (_,_,_,lod) = voxel
  w = voxelWidth lod
  (abs d < (sqrt(3.) * w /2.))

-- @noinline -- should't be compiling ptr literals src/lib/JIT.hs: 683
def rayTraceOctTreeSparse (ray:Ray) : List Voxel = 
  (AsList _ voxels) = rayTraceOctTree ray
  sdf = sdfWrap max_lod
  condition = \v. voxelContainsSurface v ray sdf
  filter condition voxels

def posInVoxel (pos:Position) (voxel:Voxel) : Bool = 
  (lowerPos, upperPos) = voxeltoBB voxel
  all for d. lowerPos.d <= pos.d && pos.d<= upperPos.d

def leafVoxel (pos:Position) : Voxel = 
  case posInVoxel pos top_voxel of
    False -> outside_root_voxel
    True -> 
      lods = max_lod -- debug
      update = \ _:(Fin lods) v:Voxel.
        childOct = subVoxelPosToChildOctant v pos
        childOctantToSubVoxel v childOct
      fold top_voxel update

---- Tests

:p rayAABBIntersection ([0., 0., 0.], [0.1, 0.1, 0.1]) ([-0.1, -0.1, -0.1], [0.1, 0.1, 0.1])

:p leafVoxel [0.1, 0.1, 0.1]


'## Raytracer for debugging

def normalize (x: d=>Float) : d=>Float = x / (length x)

-- move this somewhere else
xHat : Vec 3 = [1., 0., 0.]
yHat : Vec 3 = [0., 1., 0.]
zHat : Vec 3 = [0., 0., 1.]

RayC = (Ray & (List Voxel))

-- Assumes we're looking towards -z.
Camera =
  { numPix     : Int
  & pos        : Position  -- pinhole position
  & halfWidth  : Float     -- sensor half-width
  & sensorDist : Float }   -- pinhole-sensor distance

def cameraRays (camera:Camera) : Fin n => Fin n => RayC =
  halfWidth = getAt #halfWidth camera
  pixHalfWidth = halfWidth / IToF n
  ys = reverse $ linspace (Fin n) (neg halfWidth) halfWidth
  xs =           linspace (Fin n) (neg halfWidth) halfWidth
  for i j.
    x = xs.j
    y = ys.i
    rayPos = getAt #pos camera
    rayDir = normalize [x, y, neg (getAt #sensorDist camera)]
    ray = (rayPos, rayDir)
    rayList = rayTraceOctTreeSparse ray
    (ray, rayList)

def addAt (_:Eq n) ?=> (_:VSpace a) ?=> (xs:n=>a) (i:n) (x:a) : n=>a =
  for j. case i == j of
    True  -> xs.j + x
    False -> xs.j

def gradNumerical (n:Int) ?-> (f:Vec n -> Float) (xs:Vec n) : Vec n =
  eps = 0.0001
  for i. (f (addAt xs i eps) - f (addAt xs i (neg eps))) / (2.0 * eps)

posInf = (1.0/0.0)

def adaptiveSphereTrace (rayC:RayC) : Color = 
  maxIters = 100
  tolerance = 0.001
  (ray, (AsList n vs)) = rayC
  (rayOrigin, rayDir) = ray
  rayLength = yieldState posInf \rayLength.
    boundedIter n posInf \idxvoxel.
      currVoxel = vs.(idxvoxel@_)
      rayLength := intersectsVoxelDistance ray currVoxel + 0.01
      step = boundedIter maxIters posInf \_. 
        rayPos = rayOrigin + rayDir *. (get rayLength)
        step = sdfWrap max_lod rayPos
        rayLength := (get rayLength) + step*0.99
        case step < tolerance of
          True -> Done step
          False -> Continue
      case step == posInf of
        True -> Continue
        False -> Done zero -- this shouldn't affect anything
  rayPosOnSurf = rayOrigin + rayDir *. rayLength
  -- surfNorm = (gradNumerical \pos. sdfWrap max_lod pos) rayPosOnSurf 
  surfNorm = (grad \pos. sdfWrap max_lod pos) rayPosOnSurf 
  surfNorm 

' ### Define the scene and render it

defaultCamera = { numPix     = 100 -- 400
                , pos        = 1.0 .* zHat
                , halfWidth  = 0.3
                , sensorDist = 1.5 }

%time
rayvoxels : (Fin 100)=>(Fin 100)=>RayC = cameraRays defaultCamera

%time
canvas = for i j. adaptiveSphereTrace rayvoxels.i.j

:html imshow canvas
