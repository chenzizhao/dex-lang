-- Based on https://github.com/google-research/dex-lang/pull/586 by Sasha Rush

Len = Fin 10
I = 1@Len
J = 4@Len

-- Changes type without changing position
def rebase (i: a) ?-> (j: a) ?-> (x:(i<..)) : (j<..) =
    ((ordinal x) - ((ordinal j) - (ordinal i)))@(j<..)
K = 2@Len
rebase (0@(K<..)) : (I<..)

-- Cast based on ordinal value
def cast (d:a) : m = (ordinal d)@_
cast (1@Len) : (I<..)

-- Index arithmetic
def start : a = 0 @ a
def end : a = (size a - 1) @ a
instance Add (Fin a)
  add = \a b. ((ordinal a) + (ordinal b))@_
  sub = \a b. ((ordinal a) - (ordinal b))@_
  zero = start


def Chart (a:Type) (b:Type) : Type = i:a => (i<..) => b
def chart (ref:Ref h (Chart a b )) (i: a) (j: (i<..)) : Ref h b =
    d = %indexRef ref i
    d!j

def Params2 (b:Type) (labels:Type) : Type = labels => labels => b
def Sentence (a:Type) (b:Type) : Type = a => b

def cky [Add pos, Add semi, Mul semi]
    (sentence: Sentence pos semi)
    (deriver : semi -> semi -> semi)
    : (semi & Chart pos semi) =
    -- Initialize the chart to all zeros
    c_init : Chart pos semi  = for i. for j. zero
    (first, last) = (start, end) -- why?
    
    out = runState c_init $ \ c.
      C = chart c

      -- Enumerate over all spans d
      -- Each of these needs to be done in order
      for_ d. -- what is for_?
        boundary = last - d
        v = case ordinal d == 0 of
          True -> -- Size 1 spans are mapped to the initialized sentence
            -- modification 1
            for i' : (..<boundary).
              i = %inject i'
              sentence.i 
          False ->
            -- Main loop. No writes
            c' = get c
            for i' : (..<boundary).
              -- Calculate span (i, j)
              i = %inject i'
              j':(i<..) = cast d
              j = %inject j'
              -- Sum over k in i<..<j
              sum for k' : (i<..<j).
                  k =  %inject k'
                  -- modification 2
                  deriver c'.i.(cast k') c'.k.(rebase j')
        
        -- Fill (i, j) in the chart, one column
        for i' : (..<boundary).
          i = %inject i'
          j':(i<..) = cast d
          C i j' :=  v.i'
        ()
      
      get $ C first end
    out


' ### Define a sentence and rules

WordPos = Fin 5
Labels = Fin 6 -- N, V, Det, NP, VP, S

-- Example sentence
-- John hit the ball
-- N    V    Det   N
-- N    V    NP
-- N    VP
-- S
-- sentenceString = ["John", "hit", "the", "ball", "eos"]
-- omits the first step: tagging each word
sentence : Sentence WordPos (Labels=>Float) = [
  [1., 0., 0., 0., 0., 0.], -- John N
  [0., 1., 0., 0., 0., 0.], -- hit V
  [0., 0., 1., 0., 0., 0.], -- the Det
  [1., 0., 0., 0., 0., 0.], -- ball N
  [0., 0., 0., 0., 0., 0.]  -- EOS -- TODO needed for the types to work out..
]

-- Example weights
-- 6*6*6 cube of floats.
-- encode all binary product rules
-- labelB => labelC => labelA => Float
-- p2.b.c.a is the weight for the product rule `a->bc`
param2 : Params2 (Labels=>Float) Labels = for b c a. 
  rule = (ordinal b, ordinal c, ordinal a)
  case rule == (0,4,5) of -- N VP <- S
    True -> 1.0 
    False -> 
      case rule == (1,3,4) of -- V NP <- VP
        True -> 1.0
        False -> 
          case rule == (2,0,3) of -- Det N <- NP
            True -> 1.0
            False -> 0.0 -- rule not found

def derive 
-- for a string slice [i,j] with partition k
-- name the entire string [i,j] a
-- name substring [i,k] b
-- name substring [k,j] c
  (param2:Params2 (Labels=>Float) Labels)
  -- cube of 1.0 and 0.0 representing binary product rules
  (bvec:Labels=>Float)     -- prob distr for substring b
  (cvec:Labels=>Float)     -- prob distr for substring c
  : (avec:Labels=>Float) = -- prob distr for substring a
    for alabel. 
      sum $ for blabel.
        sum $ for clabel. 
          bvec.blabel * cvec.clabel * param2.blabel.clabel.alabel

-- test derive
bvec = [1., 0., 0., 0., 0., 0.] -- b is a N
cvec = [0., 0., 1., 0., 0., 0.] -- c is a Det
derive param2 cvec bvec -- param2 include rule `Det N -> NP`
derive param2 bvec cvec -- param2 does not include rule `N Det -> NP`

' ### Run an example

deriver = derive param2
(v, table) = cky sentence deriver

-- if the last element (S) is not zero, then the sentence can be parsed with given rules
:p v
-- cky table
:p table

-- Todo : Want this to work
-- (grad \p. log $ fst $ cky p) param 

-- todo define loss function
--  as a classifier, reward `last v == 1.0`?
--  if parsing tree info is provided, define tree1 -> tree2 -> distance?

-- (grad \p. end $ fst $ cky sentence (derive p)) param2
