Len = Fin 10
I = 1@Len
J = 4@Len

-- Changes type without changing position
def rebase (i: a) ?-> (j: a) ?-> (x:(i<..)) : (j<..) =
    ((ordinal x) - ((ordinal j) - (ordinal i)))@(j<..)
K = 2@Len
rebase (0@(K<..)) : (I<..)

-- Cast based on ordinal value
def cast (d:a) : m = (ordinal d)@_
cast (1@Len) : (I<..)

-- Index arithmetic
def start : a = 0 @ a
def end : a = (size a - 1) @ a
instance Add (Fin a)
  add = \a b. ((ordinal a) + (ordinal b))@_
  sub = \a b. ((ordinal a) - (ordinal b))@_
  zero = start


def Chart (a:Type) (b:Type) : Type = i:a => (i<..) => b
def Params (a:Type) (b:Type) (labels:Type) : Type = labels => Chart a b
def chart (ref:Ref h (Chart a b )) (i: a) (j: (i<..)) : Ref h b =
    d = %indexRef ref i
    d!j

def Params2 (b:Type) (labels:Type) : Type = labels => labels => b
def Sentence (a:Type) (b:Type) : Type = a => b

def cky [Add pos, Add semi, Mul semi]
    (sentence_ : Sentence pos_ semi_) -- todo
    (deriver : semi -> semi -> semi) -- todo
    (weights' : Params pos semi labels) 
    : (semi & Chart pos semi) =
    -- Initialize the chart to all zeros
    c_init : Chart pos semi  = for i. for j. zero
    (first, last) = (start, end) -- why?
    weights : Chart pos semi = for i j. sum for k. weights'.k.i.j
    
    out = runState c_init $ \ c. -- State: 2-D Chart, Result:
      C = chart c

      -- Enumerate over all spans d
      -- Each of these needs to be done in order
      for_ d. -- what is for_?
        boundary = last - d
        v = case ordinal d == 0 of
          -- Size 1 spans are mapped are initialized as 1
          True -> one
          False ->
            -- Main loop. No writes
            c' = get c
            for i' : (..<boundary).
              -- Calculate span (i, j)
              i = %inject i'
              j':(i<..) = cast d
              w = weights.i.j' -- for the label of substring [i,j]
              j = %inject j'
              -- Sum over k in i<..<j
              sum for k' : (i<..<j).
                  k =  %inject k'
                  -- substring [i,k] and substring [k, j]
                  w * (deriver c'.i.(cast k') c'.k.(rebase j')) 
                  -- todo do something about the labels?
        
        -- Fill (i, j) in the chart, one column
        for i' : (..<boundary).
          i = %inject i'
          j':(i<..) = cast d
          C i j' :=  v.i'
        () -- otherwise leaked variables
      get $ C first end
    out


' Run an example

WordPos = Fin 4
Labels = Fin 6 -- N, V, Det, NP, VP, S

-- Example sentence
-- John hit the ball
-- N    V    Det   N
-- N    V    NP
-- N    VP
-- S
-- sentenceString = ["John", "hit", "the", "ball"]
-- omits the first step: tagging each word
sentence : Sentence WordPos (Labels=>Float) = [
  [1., 0., 0., 0., 0., 0.], -- John N
  [0., 1., 0., 0., 0., 0.], -- hit V
  [0., 0., 1., 0., 0., 0.], -- the Det
  [1., 0., 0., 0., 0., 0.]  -- ball N
]

-- Example weights
-- 6*6*6 cube of floats.
-- encode all binary product rules
-- labelB => labelC => labelA => Float
-- p2.b.c.a is the weight for the product rule `a->bc`
param2 : Params2 (Labels=>Float) Labels = for b c a. 
  rule = (ordinal b, ordinal c, ordinal a)
  case rule == (0,4,5) of -- N VP -> S
    True -> 1.0 
    False -> 
      case rule == (1,3,4) of -- V NP -> VP
        True -> 1.0
        False -> 
          case rule == (2,0,3) of -- Det N -> NP
            True -> 1.0
            False -> 0.0 -- rule not found

def derive 
-- for a string slice [i,j] with partition k
-- name substring [i,j] a
-- name substring [i,k] b
-- name substring [k,j] c
  (param2:Params2 (Labels=>Float) Labels)
  (bvec:Labels=>Float) -- probability distr for substring b
  (cvec:Labels=>Float) -- probability distr for substring c
   -- cubic weights for binary product rules
  : (avec:Labels=>Float) = -- prob distr for substring a
    for alabel. 
      sum $ for blabel.
        sum $ for clabel. 
          bvec.blabel * cvec.clabel * param2.blabel.clabel.alabel

bvec = [1., 0., 0., 0., 0., 0.] -- b is a N
cvec = [0., 0., 1., 0., 0., 0.] -- c is a Det
derive param2 cvec bvec -- param2 include rule `Det N -> NP`
derive param2 bvec cvec -- param2 does not include rule `N Det -> NP`


key = (newKey 0)
param : Params WordPos Float Labels = for i j k. rand (ixkey2 key i (j, k))
:t param
(v, table) = cky sentence (*) param

-- Todo : Want this to work
-- (grad \p. log $ fst $ cky p) param 

-- read-only thru out the cky
param' = for i j. sum for label. param.label.i.j
:p param'

:p v
:p table
