
Label = Fin 10

Len = Fin 5
sentence = ["John", "hit", "the", "ball", "eos"]
           
I = 1@Len
J = 4@Len

-- Changes type without changing position
def rebase (i: a) ?-> (j: a) ?-> (x:(i<..)) : (j<..) =
    ((ordinal x) - ((ordinal j) - (ordinal i)))@(j<..)
K = 2@Len
rebase (0@(K<..)) : (I<..)

-- Cast based on ordinal value
def cast (d:a) : m = (ordinal d)@_
cast (1@Len) : (I<..)

-- Index arithmetic
def start : a = 0 @ a
def end : a = (size a - 1) @ a
instance Add (Fin a)
  add = \a b. ((ordinal a) + (ordinal b))@_
  sub = \a b. ((ordinal a) - (ordinal b))@_
  zero = start


def Chart (a:Type) (b:Type) : Type = i:a => (i<..) => b
def Params (a:Type) (b:Type) (labels:Type) : Type = labels => Chart a b
def chart (ref:Ref h (Chart a b )) (i: a) (j: (i<..)) : Ref h b =
    d = %indexRef ref i
    d!j

c1 : Chart (Fin 3) Float = for i j. 3.0
:p c1
-- Chart defines an upside down triangle matrix. 
--   The first column denotes all size-1 spans
--   The last column denotes the entire string
--   The element at i-th row and j-th column, is value stored for 
--      the inclusive string slice [i,j]. 

p1 : Params (Fin 3) Float (Fin 4) = for i j k. 2.0
:p p1

def cky [Add pos, Add semi, Mul semi] (weights' : Params pos semi labels) : (semi & Chart pos semi) =
    -- Initialize the chart to all zeros
    c_init : Chart pos semi  = for i. for j. zero
    (first, last) = (start, end) -- why?
    -- Sum out the labels -- why?
    weights : Chart pos semi = for i j. sum for k. weights'.k.i.j
    out = runState c_init $ \ c. -- State: 2-D Chart, Result:
      C = chart c

      -- Enumerate over all spans d
      -- Each of these needs to be done in order
      for_ d. -- what is for_?
        boundary = last - d
        v = case ordinal d == 0 of
          -- Size 1 spans are mapped are initialized as 1
          True -> one
          False ->
            -- Main loop. No writes
            c' = get c
            for i' : (..<boundary).
              -- Calculate span (i, j)
              i = %inject i'
              j':(i<..) = cast d
              w = weights.i.j' -- for the label of substring [i,j]
              j = %inject j'
              -- Sum over k in i<..<j
              sum for k' : (i<..<j).
                  k =  %inject k'
                  -- substring [i,k] and substring [k, j]
                  c'.i.(cast k') * c'.k.(rebase j') * w 
                  -- todo do something about the labels?
        
        -- Fill (i, j) in the chart, one column
        for i' : (..<boundary).
          i = %inject i'
          j':(i<..) = cast d
          C i j' :=  v.i'
        () -- otherwise leaked variables
      get $ C first end
    out


' Run an example

WordPos = Fin 7
Labels = Fin 10

key =  (newKey 0)
param : Params WordPos Float Labels = for i j k. rand (ixkey2 key i (j, k))
(v, table) = cky param

-- Todo : Want this to work
-- (grad \p. log $ fst $ cky p) param 

-- read-only thru out the cky
param' = for i j. sum for label. param.label.i.j
:p param'

:p v
:p table
:t table
