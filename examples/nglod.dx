' ## Reimplement NGLOD - OctreeSDF
<https://github.com/nv-tlabs/nglod/blob/main/sdf-net/lib/models/OctreeSDF.py>
2D only

import plot
key = newKey 0

Height = Fin 100
Width = Fin 100
Position_t = Fin 2
Feature_t = Fin 3
Position = Position_t => Float
Feature = Feature_t => Float
Distance = Float
LOD = Int

instance [Add a, Add b] Add (a & b)
  add = \(a, b) (c, d). ( (a + c), (b + d))
  sub = \(a, b) (c, d). ( (a - c), (b - d))
  zero = (zero, zero)

instance [VSpace a, VSpace b] VSpace (a & b)
  scaleVec = \ s (a, b) . (scaleVec s a, scaleVec s b)

def plotsdfpoint (sdf:(Position -> Distance)) (x:Height) (y:Width) : Distance = 
    center = IToF (size Height)/2.
    l = ((IToF ((ordinal y)) - center) / IToF (size Height))
    v = ((IToF ((ordinal x)) - center) / IToF (size Width))
    sdf [l, v]

def plotsdf (sdf:(Position -> Distance)) : Height=>Width=>Distance = 
    for x y.
        plotsdfpoint sdf x y

' ### Construct a target 2D SDF

def circlesdf (p:Position) (r:Float):Distance = 
    dist = sqrt $ sum $ for d. (sq p.d)
    max dist r

def squaresdf (p:Position) (center:Position) (halfedge:Float):Distance = 
    is_in_square_arr = for d. halfedge > abs (p.d-center.d)
    if (all is_in_square_arr) then 0. else 1.

def targetSDF (p:Position):Distance = 
    r1 = 0.05
    r2 = 0.10
    offset2 : Position = [0.20, 0.05]
    d1 = circlesdf p r1
    d3 = squaresdf p offset2 r2
    -- min d1 d3
    d3

target = plotsdf targetSDF

' ### Build the OctreeSDF

Hidden_t = Fin 128
In_t = {leftout: Position_t | rightout: Feature_t}
Out_t = Fin 1
WnB : Type = (In_t=>Hidden_t=>Float & Hidden_t => Float & Hidden_t => Out_t => Float & Out_t=>Float)
-- currently only support joint decoder mode TODO-1
joint_decoder_mode = True

instance [Arbitrary a] Arbitrary (In_t=>Float)
    arb = \key.
        for ind.
            [keyl, keyr] = splitKey $ ixkey key ind
            case ind of
                {| leftout = i  |} -> arb keyl
                {| rightout = i |} -> arb keyr

' ##### the Octree part

def linearInterp (x1:Float) (x2:Float) (k1:Float) (k2:Float) (x:Float) : Float = 
    w = (x-x1) / (x2-x1)
    k1 * (1.0 - w) + k2 * w

def bilinearInterp
        (p1:Position) (p2:Position) (p3:Position) (p4:Position)
        (k1:Float) (k2:Float) (k3:Float) (k4:Float)
        (p:Position) : Float = 
    -- assume the following geometric arrangement
    --
    --  0------------W (dim 1)
    --  |   p1    p3
    --  |      p
    --  |   p2    p4 
    --  H(dim 0)
    --
    v1 = linearInterp p1.(0@_) p2.(0@_) k1 k2 p.(0@_)
    v2 = linearInterp p3.(0@_) p4.(0@_) k3 k4 p.(0@_)
    linearInterp p1.(1@_) p3.(1@_) v1 v2 p.(1@_)

def InputSubTable (edge:LOD) : Type = (Fin edge)=>(Fin edge)=>Float

def InputTable (edge:LOD) : Type = Feature_t => InputSubTable edge

-- ARB
def getInputTable (edge:LOD): (InputTable edge) = 
    -- [ feature_sz x edge x edge ] * 0.01
    scaleVec 0.01 $ arb key

def tableSize (t:n=>m): Int = size n

def boundBy [Ord o] (min:o) (max:o) (x:o) : o = 
    x' = select (x>max) max x
    select (x<min) min x'

def queryInputTable (pos:Position) (table: InputSubTable n) : Float = 
    h = FToI pos.(0@_)
    w = FToI pos.(1@_)
    -- pad by boundary
    edge = tableSize table
    h' = boundBy 0 (edge-1) h
    w' = boundBy 0 (edge-1) w
    table.(h'@_).(w'@_)

-- "FeatureVolume.forward" in OctreeSDF
-- reimplementing torch.nn.Functional.grid_sample 
def spatialFeatures (edge:Int) (x:Position) : Feature = 
    edge1 = edge+1
    inputTable = getInputTable edge1
    inputPos = reverse for d. IToF edge / 2.0 * (x.d+1.)
    p1w = floor inputPos.(0@_)
    p1h = floor inputPos.(1@_)
    p1 = [p1h, p1w]
    p2 = [p1h+1., p1w]
    p3 = [p1h, p1w+1.]
    p4 = [p1h+1., p1w+1.]
    for f:Feature_t.
        k1 = queryInputTable p1 inputTable.f
        k2 = queryInputTable p2 inputTable.f
        k3 = queryInputTable p3 inputTable.f
        k4 = queryInputTable p4 inputTable.f
        bilinearInterp p1 p2 p3 p4 k1 k2 k3 k4 inputPos

-- assume position normalized between -1 and +1
test_pos = [-1.0, 1.0]
%time
spatialFeatures 2 test_pos

' output = grid_sample(input, grid) is a function used in the original OctreeSDF <https://www.programmersought.com/article/10374524300/>
<https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.grid_sample> here only the 4D input grid_sample is implemented

' ##### the neural net part

def mlp (v1: In_t=>Float) ((w1,b1,w2,b2): WnB) : Out_t=>Float = 
    relu = \x.(max x 0.)
    v2 = map relu $ (transpose w1) **. v1 + b1
    (transpose w2) **. v2 + b2

def l2losspoint (sdf: Position->Distance) (point:(Height&Width)) : Float = 
    (i, j) = point
    pred = plotsdfpoint sdf i j
    sq $ pred - target.i.j

def l2loss (sdf: Position->Distance) (target: Height=>Width=>Float) : Float = 
    pred = plotsdf sdf
    diff2 = sq (pred-target)
    sum for i. sum diff2.i

' ##### Combine Octree and nn

def concatTable (left: a=>v) (right: b=>v) : ({leftout:a | rightout:b }=>v) =
  for idx. case idx of
    {| leftout = i  |} -> left.i
    {| rightout = i |} -> right.i

def octreeSDF (lod:LOD) (wnb:WnB) (x:Position): Distance = 
    z:Feature = yieldState zero \z_ref.
        for i:(Fin lod).
            -- Is this really right? TODO-3 
            edge = FToI $ pow 2. $ IToF $ ordinal i
            -- edge = ordinal i
            z_cur = get z_ref
            z_ref := z_cur + spatialFeatures edge x
    input = concatTable x z
    out = mlp input wnb
    out.(0@_)

' ### Training

lod : LOD = 3
lr : Float = 0.01
iters : Int = 20000
minibatch_sz : Int = 5
catch do assert $ (size Height) * (size Width) > minibatch_sz

%time
wnb_sgd:WnB = yieldState (arb key) \wnb_ref.
    for i:(Fin iters).
        keyi = ixkey key i
        wnb = get wnb_ref
        samples = for k : (Fin minibatch_sz).
            [keyx, keyy] = splitKey $ ixkey keyi k
            (arb keyx, arb keyy)
        loss = \w.
            curr_sdf = \x. (octreeSDF lod w x)
            pointlosswrap = \point. (l2losspoint curr_sdf point)
            mean $ for k. pointlosswrap samples.k
        gradient = (grad loss) wnb
        wnb_ref := wnb - scaleVec lr gradient

final_sdf = \x. octreeSDF lod wnb_sgd x
final_loss = l2loss final_sdf target
:p final_loss

:html matshow target

im = plotsdf final_sdf
:html matshow im

-- TODO-2 raymarch to render SDF
