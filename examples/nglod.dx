' ## Reimplement NGLOD - OctreeSDF
<https://github.com/nv-tlabs/nglod/blob/main/sdf-net/lib/models/OctreeSDF.py>
2D only

key = newKey 0
import plot

Height = Fin 10
Width = Fin 10
-- should be more pixels
Position_t = Fin 2
Feature_t = Fin 0
-- should be 32 features
Position = Fin 2 => Float
Feature = Fin 0 => Float
-- should be 32 features
Distance = Float
LOD = Int

def plotsdfpoint (sdf:(Position -> Distance)) (x:Height) (y:Width) : Distance = 
    center = IToF (size Height)/2.
    l = ((IToF ((ordinal y)) - center) / IToF (size Height))
    v = ((IToF ((ordinal x)) - center) / IToF (size Width))
    sdf [l*1., v*1.]

def plotsdf (sdf:(Position -> Distance)) : Height=>Width=>Distance = 
    for x y.
        plotsdfpoint sdf x y

' ### Construct a target 2D SDF

def circlesdf (p:Position) (r:Float):Distance = 
    dist = sqrt $ sum $ for d. (sq p.d)
    max dist r

def squaresdf (p:Position) (center:Position) (halfedge:Float):Distance = 
    is_in_square_arr = for d. halfedge > abs (p.d-center.d)
    if (all is_in_square_arr) then 0. else 1.

def targetSDF (p:Position):Distance = 
    r1 = 0.05
    r2 = 0.10
    offset2 : Position = [0.20, 0.05]
    d1 = circlesdf p r1
    d3 = squaresdf p offset2 r2
    -- min d1 d3
    d3

target = plotsdf targetSDF
-- :html matshow target


' ### Build the OctreeSDF

-- parameters
Hidden_t = Fin 128
In_t = {leftout: Position_t | rightout: Feature_t}
Out_t = Fin 1
WnB : Type = (In_t=>Hidden_t=>Float & Hidden_t => Float & Hidden_t => Out_t => Float & Out_t=>Float)
-- only support joint decoder mode TODO-1
joint_decoder_mode = True

' ##### the Octree part

-- linear_interp is a helper funcion of bilinear_interp
def linear_interp
        (x1:Float) (x2:Float) 
        (k1:Float) (k2:Float) 
        (x:Float) : Float = 
    w = (x-x1) / (x2-x1)
    k1 * (1.-w) + k2 * w

-- bilinear_interp is a helper function of spatial_features
def bilinear_interp
        (p1:Position) (p2:Position) (p3:Position) (p4:Position)
        (k1:Float) (k2:Float) (k3:Float) (k4:Float)
        (p:Position) : Float = 
    -- assume the following geometric arrangement
    --
    --  0------------W (dim 1)
    --  |   p1    p3
    --  |      p
    --  |   p2    p4 
    --  H(dim 0)
    --
    v1 = linear_interp p1.(0@_) p2.(0@_) k1 k2 p.(0@_)
    v2 = linear_interp p3.(0@_) p4.(0@_) k3 k4 p.(0@_)
    v3 = linear_interp p1.(1@_) p3.(1@_) v1 v2 p.(1@_)
    v3

-- "FeatureVolume.forward" in OctreeSDF
-- reimplementing torch.nn.Functional.grid_sample 
def spatial_features (lod:LOD) (x:Position) : Feature = 
    -- TODO-2
    zero

' output = grid_sample(input, grid) is a function used in the original OctreeSDF <https://www.programmersought.com/article/10374524300/>
<https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.grid_sample> here only the 4D input grid_sample is implemented

' ##### the neural net part

def maximum2 [Ord o] (xs:n=>o) : o = 
    fold xs.(0@_) \i curr. max curr xs.i

def softmax2 (x: n=>Float) : n=>Float =
  m = maximum2 x
  e =  for i. exp (x.i - m)
  s = sum e
  for i. e.i / s

def mlp (v1: In_t=>Float) ((w1,b1,w2,b2): WnB)
        : Out_t=>Float = 
    -- two linear layers with relu activation in between
    relu = \x.(max x 0.)
    v2 = map relu $ (transpose w1) **. v1 + b1
    softmax2 $ (transpose w2) **. v2 + b2

' ##### Combine Octree and nn

def concatTable (left: a=>v) (right: b=>v) : ({leftout:a | rightout:b }=>v) =
  for idx. case idx of
    {| leftout = i  |} -> left.i
    {| rightout = i |} -> right.i

def OctreeSDF (lod:LOD) (wnb:WnB) (x:Position): Distance = 
    z:Feature = yieldState zero \z_ref.
            for i:(Fin lod).
                lod = ordinal i
                z_cur = get z_ref
                z_ref := z_cur + spatial_features lod x
    input = concatTable x z
    out = mlp input wnb
    out.(0@_)

' ### Training

instance [Arbitrary a] Arbitrary (In_t=>Float)
    arb = \key.
        for ind.
            [keyl, keyr] = splitKey $ ixkey key ind
            case ind of
                {| leftout = i  |} -> arb keyl
                {| rightout = i |} -> arb keyr

def l2losspoint (wnb: WnB) (lod: LOD) (point:(Height&Width)) : Float = 
    (i, j) = point
    curr_sdf = \x. (OctreeSDF lod wnb x)
    pred = plotsdfpoint curr_sdf i j
    sq $ pred - target.i.j

def l2loss (wnb: WnB) (lod: LOD) : Float = 
    pred = plotsdf \x.(OctreeSDF lod wnb x)
    diff2 = for i j. sq $ target.i.j-pred.i.j 
    sumofsq = sum $ for i. sum diff2.i
    n = (size Height) * (size Width)
    sumofsq / IToF n

instance [Add a, Add b] Add (a & b)
  add = \(a, b) (c, d). ( (a + c), (b + d))
  sub = \(a, b) (c, d). ( (a - c), (b - d))
  zero = (zero, zero)

instance [VSpace a, VSpace b] VSpace (a & b)
  scaleVec = \ s (a, b) . (scaleVec s a, scaleVec s b)

-- training parameters
lod : LOD = 1
lr : Float = 0.01
iters : Int = 10000

sz_sgd : Int = 5
catch do assert $ (size Height) * (size Width) > sz_sgd

wnbout:WnB = yieldState (arb key) \wnb_ref.
    for i:(Fin iters).
        wnb = get wnb_ref
        loss = \w. (l2loss w lod)
        gradient = (grad loss) wnb
        wnb_ref := wnb - scaleVec lr gradient

'wnbout_sgd:WnB = yieldState (arb key) \wnb_ref.
    for i:(Fin iters).
        keyi = ixkey key i
        wnb = get wnb_ref
        samples = for k : (Fin sz_sgd).
            [keyx, keyy] = splitKey $ ixkey keyi k
            (arb keyx, arb keyy)
        loss = \w.
            pointlosswrap = \point. (l2losspoint w lod point)
            mean $ for k. pointlosswrap samples.k
        gradient = (grad loss) wnb
        wnb_ref := wnb - scaleVec lr gradient

:html matshow target

wnbinit:WnB = arb key
im1 = plotsdf \x. (OctreeSDF lod wnbinit x)
:html matshow im1

im2 = plotsdf \x. OctreeSDF lod wnbout x
:html matshow im2

-- im3 = plotsdf \x. OctreeSDF lod wnbout_sgd x
-- :html matshow im3

:p target
:p im1
:p im2

-- TODO-3 raymarch to render
