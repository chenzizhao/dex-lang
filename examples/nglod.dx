' ## Reimplement NGLOD - OctreeSDF
<https://github.com/nv-tlabs/nglod/blob/main/sdf-net/lib/models/OctreeSDF.py>

import plot
key = newKey 0

Depth = Fin 100
Height = Fin 100
Width = Fin 100
Position_t = Fin 3
Feature_t = Fin 3
Position = Position_t => Float
Feature = Feature_t => Float
Distance = Float

instance [Add a, Add b] Add (a & b)
    add = \(a, b) (c, d). ( (a + c), (b + d))
    sub = \(a, b) (c, d). ( (a - c), (b - d))
    zero = (zero, zero)

instance [VSpace a, VSpace b] VSpace (a & b)
    scaleVec = \ s (a, b) . (scaleVec s a, scaleVec s b)

def length (x: d=>Float) : Float = sqrt $ sum for i. sq x.i

def ind2NormalizedPos (idx: Fin n) : Float =
    -- requirement n>=2
    2.*(IToF $ ordinal idx) / (IToF n - 1.) - 1.

:p for i:(Fin 11). ind2NormalizedPos i

-- SDF should only accept normalized position [-1., 1.]
-- TODO-5 enforce this with type system.

def plotSdfPoint
	(sdf:(Position -> Distance))
	(x:Fin n) (y:Fin m) (z:Fin o): Distance =
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    z' = ind2NormalizedPos z
    sdf [x', y', z']

def plotSdf
	(sdf:(Position -> Distance))
	: (Fin n)=>(Fin m)=>(Fin o)=>Distance =
    for x y z. plotSdfPoint sdf x y z

' ### Construct a target 3D SDF

def circleSdf (p:Position) (r:Float) : Distance =
    dist = sqrt $ sum $ for d. (sq p.d)
    max dist r

-- TODO modify the absolute positions ...

def sdSphere (pos:Position) (spherePos:Position) (r:Float) : Distance = 
  pos' = pos - spherePos
  max (length pos' - r) 0.0

def targetSdf (p:Position) : Distance =
    sdSphere p [-0.6, -0.7,  -0.2] 0.3

%time
target : Depth=>Height=>Width=>Float = plotSdf targetSdf

:html matshow target.(0@Depth)

:html matshow target.(5@Depth)

' ### Build the OctreeSDF

Hidden_t = Fin 128
-- In_t = {leftout: Position_t | rightout: Feature_t}
In_t = Fin 6
Out_t = Fin 1
WnB : Type = (In_t=>Hidden_t=>Float & Hidden_t => Float & Hidden_t => Out_t => Float & Out_t=>Float)
-- TODO-6 new data type for WnB
-- currently only support joint decoder mode TODO-1 WIP
joint_decoder_mode = True

-- instance [Arbitrary a] Arbitrary (In_t=>Float)
--     arb = \key.
--         for ind.
--             [keyl, keyr] = splitKey $ ixkey key ind
--             case ind of
--                 {| leftout = i  |} -> arb keyl
--                 {| rightout = i |} -> arb keyr

' ##### the Octree part

def Vec (n:Int) : Type = (Fin n)=>Float

def linearInterp [VSpace a] (x1:Float) (x2:Float) (k1:a) (k2:a) (x:Float) : a =
    --     x1   x       x2
    -- ----------------------->
    --     k1   ?       k2
    w = (x-x1) / (x2-x1)
    scaleVec (1.0 - w) k1 + scaleVec w k2

def bilinearInterp [VSpace a]
	(p1:Vec 2) (p2:Vec 2) (p3:Vec 2) (p4:Vec 2)
	(k1:a) (k2:a) (k3:a) (k4:a)
	(p:Vec 2) : a =
    --
    --  p1, p2, p4, p3 form a square
    --  0------------(dim 1)
    --  |   p1    p3
    --  |      p
    --  |   p2    p4
    --  (dim 0)
    --
    k5 = linearInterp p1.(0@_) p2.(0@_) k1 k2 p.(0@_)
    k6 = linearInterp p3.(0@_) p4.(0@_) k3 k4 p.(0@_)
    linearInterp p1.(1@_) p3.(1@_) k5 k6 p.(1@_)

def trilinearInterp [VSpace a]
	(p1:Vec 3) (p2:Vec 3) (p3:Vec 3) (p4:Vec 3)
	(p5:Vec 3) (p6:Vec 3) (p7:Vec 3) (p8:Vec 3)
	(k1:a) (k2:a) (k3:a) (k4:a)
	(k5:a) (k6:a) (k7:a) (k8:a)
	(p:Vec 3) : a =
    -- n@(dim 0)   0------------(dim 2)
    --             |   p1    p3
    --             |      p
    --             |   p2    p4
    --             (dim 1)
    -- n+1@(dim 0) 0------------(dim 2)
    --             |   p5    p7
    --             |      p
    --             |   p6    p8
    --             (dim 1)
    dropHead : Vec 3 -> Vec 2 = \v3. [v3.(1@_), v3.(2@_)]
    k9  = bilinearInterp (dropHead p1) (dropHead p2) (dropHead p3) (dropHead p4) k1 k2 k3 k4 (dropHead p)
    k10 = bilinearInterp (dropHead p5) (dropHead p6) (dropHead p7) (dropHead p8) k5 k6 k7 k8 (dropHead p)
    linearInterp p1.(0@_) p5.(0@_) k9 k10 p.(0@_)

data InputTable = 
    MkInputTable edgeLen:Int (Fin edgeLen => Fin edgeLen => Fin edgeLen => Feature)

def boundBy [Ord o] (min:o) (max:o) (x:o) : o =
    x' = select (x>max) max x
    select (x<min) min x'

def queryInputTable ((MkInputTable edgeLen table): InputTable) ([d, h, w]:Position) : Feature =
    d' = boundBy 0 (edgeLen-1) (FToI d)
    h' = boundBy 0 (edgeLen-1) (FToI h)
    w' = boundBy 0 (edgeLen-1) (FToI w)
    table.(d'@_).(h'@_).(w'@_)

def normalizedPos2Ind (normalizedPos:Float) (sz:Int) : Float =
    -- -1.0------------>+1.0
    -- 0.0 ------------>sz-1
    (normalizedPos + 1.0) / 2.0 * (IToF (sz-1))

def getInputTable [Arbitrary a]: (Fin edgeLen => Fin edgeLen => Fin edgeLen => a) = 
    arb key

-- TODO
def badname(x:n=>m=>o=>p=>Float) : n=>m=>o=>p=>Float =
    for i j k l.
        y = x.i.j.k.l
        2.0 * (y- floor y - 0.5)

def intpow2 (power:Int) : Int = %shl 1 power

-- "FeatureVolume.forward" in OctreeSDF
-- reimplementing torch.nn.Functional.grid_sample
def spatialFeatures
        (inputTable:InputTable)
        (normalizedPos:Position) : Feature =
    (MkInputTable edgeLen table) = inputTable
    inputPos = for d. normalizedPos2Ind normalizedPos.d edgeLen
    [p1d, p1h, p1w] = map floor inputPos
    p1 = [p1d, p1h, p1w]
    p2 = [p1d, p1h+1., p1w]
    p3 = [p1d, p1h, p1w+1.]
    p4 = [p1d, p1h+1., p1w+1.]
    p5 = [p1d+1., p1h, p1w]
    p6 = [p1d+1., p1h+1., p1w]
    p7 = [p1d+1., p1h, p1w+1.]
    p8 = [p1d+1., p1h+1., p1w+1.]
    [k1, k2, k3, k4, k5, k6, k7, k8] = map (queryInputTable inputTable) [p1, p2, p3, p4, p5, p6, p7, p8]
    trilinearInterp p1 p2 p3 p4 p5 p6 p7 p8 k1 k2 k3 k4 k5 k6 k7 k8 inputPos

inputTable4 = MkInputTable 16 (badname getInputTable)

edgeLenTest = intpow2 4
inputTableTest = MkInputTable edgeLenTest (badname getInputTable)
:t inputTable4
:t inputTableTest

%time
test_im : (Fin 10) => (Fin 10) => (Fin 10) => Color = for x y z.
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    z' = ind2NormalizedPos z
    spatialFeatures inputTable4 [x', y', z']

-- -- should be continuous
:html imshow test_im.(5@(Fin 10))

' output = grid_sample(input, grid) is a function used in the original OctreeSDF <https://www.programmersought.com/article/10374524300/>
<https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.grid_sample> here only the 4D input grid_sample is implemented

' ##### the neural net part

def mlp (v1: In_t=>Float) ((w1,b1,w2,b2): WnB) : Out_t=>Float =
    relu = \x.(max x 0.)
    v2 = map relu $ (transpose w1) **. v1 + b1
    (transpose w2) **. v2 + b2

def l2losspoint (sdf: Position->Distance) (point: (Depth&Height&Width)) : Float =
    (x, y, z) = point
    pred = plotSdfPoint sdf x y z
    sq $ pred - target.x.y.z

def l2loss (sdf: Position->Distance) : Float =
    pred = plotSdf sdf
    diff2 = sq (pred-target)
    mean for i. mean for j. mean diff2.i.j

' ##### Combine Octree and nn

def concatTable (x:a=>v) (y:b=>v) : c=>v = 
  for i:c.
    if (ordinal i) < (size a) 
      then
        x.((ordinal i)@a)
      else
        y.(((ordinal i) - (size a))@b)


def octreeSDF
    (inputTable: InputTable)
    (wnb: WnB) (x: Position) : Distance =
    -- z:Feature = yieldState zero \z_ref.
        -- yieldAccum TODO-4
    --    for i:(Fin lod).
    --        z_cur = get z_ref
    --        z_ref := z_cur + spatialFeatures lod x
    z = spatialFeatures inputTable x
    input : (Fin 6)=>Float = concatTable x z
    out = mlp input wnb
    out.(0@_)

' ### Training

lr : Float = 0.01
iters : Int = 10000
minibatch_sz : Int = 5
-- train weigths for multiple lods
lod_max = 2
:p for i:(Fin lod_max). ordinal i

%time
input_tables = for lod: (Fin lod_max). 
    edgeLen = intpow2 $ ordinal lod
    MkInputTable edgeLen (badname getInputTable)

%time
wnb_sgds = for lod.
    inputTable = input_tables.lod
    yieldState (arb key) \wnb_ref.
        for i:(Fin iters).
            keyi = ixkey key i
            wnb = get wnb_ref
            samples = for k:(Fin minibatch_sz). arb $ ixkey keyi k
            loss = \w.
                curr_sdf = \x. octreeSDF inputTable w x
                mean $ for k. l2losspoint curr_sdf samples.k
            gradient = (grad loss) wnb
            wnb_ref := wnb - scaleVec lr gradient

%time
final_sdfs = for lod.
    \x. octreeSDF input_tables.lod wnb_sgds.lod x

final_losses = for lod. 
    l2loss final_sdfs.lod
:p final_losses

%time
im2 : Depth=>Height=>Width=>Float = plotSdf final_sdfs.(1@_)
:html matshow im2.(5@Depth)
:html matshow target.(5@Depth)


' ### Rendering
- adpative *
- sphere tracing *
- uniform light source
- remove mirror
- build a target volume of some complexity
- rotating volume gif (later)

' ## Rendering (from Raytracer)
- adpative *
- sphere tracing *
- uniform light source
- build a target volume of some complexity (merge the block & the sphere)
- rotating volume gif (later)

def Mat (n:Int) (m:Int) : Type = Fin n => Fin m => Float
def relu (x:Float) : Float = max x 0.0
-- TODO: make a newtype for normal vectors
def normalize (x: d=>Float) : d=>Float = x / (length x)
def directionAndLength (x: d=>Float) : (d=>Float & Float) =
  l = length x
  (x / (length x), l)

def randuniform (lower:Float) (upper:Float) (k:Key) : Float =
  lower + (rand k) * (upper - lower)

def sampleAveraged [VSpace a] (sample:Key -> a) (n:Int) (k:Key) : a =
  yieldState zero \total.
    for i:(Fin n).
      total := get total + sample (ixkey k i) / IToF n

def positiveProjection (x:n=>Float) (y:n=>Float) : Bool = dot x y > 0.0

' ### 3D Helper Functions

def cross (a:Vec 3) (b:Vec 3) : Vec 3 =
  [a1, a2, a3] = a
  [b1, b2, b3] = b
  [a2 * b3 - a3 * b2, a3 * b1 - a1 * b3, a1 * b2 - a2 * b1]

-- TODO: Use `data Color = Red | Green | Blue` and ADTs for index sets
data Image =
 MkImage height:Int width:Int (Fin height => Fin width => Color)

xHat : Vec 3 = [1., 0., 0.]
yHat : Vec 3 = [0., 1., 0.]
zHat : Vec 3 = [0., 0., 1.]

Angle = Float  -- angle in radians

def rotateX (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [px, c*py - s*pz, s*py + c*pz]

def rotateY (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [c*px + s*pz, py, - s*px+ c*pz]

def rotateZ (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [c*px - s*py, s*px+c*py, pz]

def sampleCosineWeightedHemisphere (normal: Vec 3) (k:Key) : Vec 3 =
  [k1, k2] = splitKey k
  u1 = rand k1
  u2 = rand k2
  uu = normalize $ cross normal [0.0, 1.1, 1.1]
  vv = cross uu normal
  ra = sqrt u2
  rx = ra * cos (2.0 * pi * u1)
  ry = ra * sin (2.0 * pi * u1)
  rz = sqrt (1.0 - u2)
  rr = (rx .* uu) + (ry .* vv) + (rz .* normal)
  normalize rr

' ### Raytracer

Direction = Vec 3  -- Should be normalized. TODO: use a newtype wrapper

BlockHalfWidths = Vec 3
Radius = Float
Radiance = Color

data ObjectGeom =
  Wall Direction Distance
  Block Position BlockHalfWidths Angle
  Sphere Position Radius

data Surface =
  Matte Color
  Mirror

OrientedSurface = (Direction & Surface)

data Object =
  PassiveObject ObjectGeom Surface
  -- position, half-width, intensity (assumed to point down)
  Light Position Float Radiance

Ray = (Position & Direction)
Filter   = Color

-- TODO: use a record
-- num samples, num bounces, share seed?
Params = { numSamples : Int
         & maxBounces : Int
         & shareSeed  : Bool }

-- TODO: use a list instead, once they work
data Scene n:Type = MkScene (n=>Object)

def sampleReflection ((nor, surf):OrientedSurface) ((pos, dir):Ray) (k:Key) : Ray =
  newDir = case surf of
    Matte _ -> sampleCosineWeightedHemisphere nor k
    -- TODO: surely there's some change-of-solid-angle correction we need to
    -- consider when reflecting off a curved surface.
    Mirror  -> dir - (2.0 * dot dir nor) .* nor
  (pos, newDir)

def probReflection ((nor, surf):OrientedSurface) (_:Ray) ((_, outRayDir):Ray) : Float =
  case surf of
    Matte _ -> relu $ dot nor outRayDir
    Mirror  -> 0.0  -- TODO: this should be a delta function of some sort

def applyFilter (filter:Filter) (radiance:Radiance) : Radiance =
  for i. filter.i * radiance.i

def surfaceFilter (filter:Filter) (surf:Surface) : Filter =
  case surf of
    Matte color -> for i. filter.i * color.i
    Mirror      -> filter


-- -- the target sdf function
-- def sdSphere (pos:Position) (spherePos:Position) (r:Float) : Distance = 
--   pos' = pos - spherePos
--   max (length pos' - r) 0.0


-- def mytempbound(pos:Position) : Position = 
--     for i:(Fin 3). 
--         max = 1.0
--         min = 1.0
--         x' = select (x>max) max x
--         select (x<min) min x'
--         -- boundBy (1.0) 1.0 pos.i
-- 
-- def mytempbound2(pos:Position) : Position = 
--     [1.0, 1.0, 1.0]
-- 
-- mytempbound [1.0, -2.0, 10.0]
-- mytempbound2 [1.0, -2.0, 10.0]

def sdSphereApprox (pos:Position) (lod:Int): Distance = 
  (final_sdfs.(0@_)) (pos) -- <== adapter modified

sdSphereApprox [1.0, 1.0, 1.0] 1
sdSphereApprox [1.0, 1.0, 20.0] 1

def sdObject (pos:Position) (obj:Object) : Distance =
  case obj of -- replace each of these with a nn. 
    PassiveObject geom _ -> case geom of
      Wall nor d -> d + dot nor pos
      Block blockPos halfWidths angle ->
        pos' = rotateY (pos - blockPos) angle
        length $ for i. max ((abs pos'.i) - halfWidths.i) 0.0
      Sphere spherePos r -> 
        -- sdSphere pos spherePos r -- <== select original
        sdSphereApprox pos 1 -- <== select new
    Light squarePos hw _ ->
      pos' = pos - squarePos
      halfWidths = [hw, 0.01, hw]
      length $ for i. max ((abs pos'.i) - halfWidths.i) 0.0

def sdScene (scene:Scene n) (pos:Position) : (Object & Distance) =
  (MkScene objs) = scene
  (i, d) = minimumBy snd $ for i. (i, sdObject pos objs.i)
  (objs.i, d)

def calcNormal (obj:Object) (pos:Position) : Direction =
  normalize (grad (flip sdObject obj) pos)

data RayMarchResult =
  -- incident ray, surface normal, surface properties
  HitObj Ray OrientedSurface
  HitLight Radiance
  -- Could refine with failure reason (beyond horizon, failed to converge etc)
  HitNothing

def raymarch (scene:Scene n) (ray:Ray) : RayMarchResult =
  maxIters = 100
  tol = 0.01
  startLength = 10.0 * tol  -- trying to escape the current surface
  (rayOrigin, rayDir) = ray
  withState (10.0 * tol) \rayLength.
    boundedIter maxIters HitNothing \_.
      rayPos = rayOrigin + get rayLength .* rayDir
      (obj, d) = sdScene scene $ rayPos
      -- 0.9 ensures we come close to the surface but don't touch it
      rayLength := get rayLength + 0.9 * d
      case d < tol of
        False -> Continue
        True ->
          surfNorm = calcNormal obj rayPos
          case positiveProjection rayDir surfNorm of
            True ->
              -- Oops, we didn't escape the surface we're leaving..
              -- (Is there a more standard way to do this?)
              Continue
            False ->
              -- We made it!
              Done $ case obj of
                PassiveObject _ surf -> HitObj (rayPos, rayDir) (surfNorm, surf)
                Light _ _ radiance   -> HitLight radiance

def rayDirectRadiance (scene:Scene n) (ray:Ray) : Radiance =
  case raymarch scene ray of
    HitLight intensity -> intensity
    HitNothing -> zero
    HitObj _ _ -> zero

def sampleSquare (hw:Float) (k:Key) : Position =
 [kx, kz] = splitKey k
 x = randuniform (- hw) hw kx
 z = randuniform (- hw) hw kz
 [x, 0.0, z]

def sampleLightRadiance
      (scene:Scene n) (osurf:OrientedSurface) (inRay:Ray) (k:Key) : Radiance =
  (surfNor, surf) = osurf
  (rayPos, _) = inRay
  (MkScene objs) = scene
  yieldAccum (AddMonoid Float) \radiance.
    for i. case objs.i of
      PassiveObject _ _ -> ()
      Light lightPos hw _ ->
        (dirToLight, distToLight) = directionAndLength $
                                      lightPos + sampleSquare hw k - rayPos
        if positiveProjection dirToLight surfNor then
          -- light on this far side of current surface
          fracSolidAngle = (relu $ dot dirToLight yHat) * sq hw / (pi * sq distToLight)
          outRay = (rayPos, dirToLight)
          coeff = fracSolidAngle * probReflection osurf inRay outRay
          radiance += coeff .* rayDirectRadiance scene outRay

def trace (params:Params) (scene:Scene n) (initRay:Ray) (k:Key) : Color =
  noFilter = [1.0, 1.0, 1.0]
  yieldAccum (AddMonoid Float) \radiance.
    runState  noFilter \filter.
     runState initRay  \ray.
      boundedIter (getAt #maxBounces params) () \i.
        case raymarch scene $ get ray of
          HitNothing -> Done ()
          HitLight intensity ->
            if i == 0 then radiance += intensity   -- TODO: scale etc
            Done ()
          HitObj incidentRay osurf ->
            [k1, k2] = splitKey $ hash k i
            lightRadiance = sampleLightRadiance scene osurf incidentRay k1
            ray    := sampleReflection osurf incidentRay k2
            filter := surfaceFilter (get filter) (snd osurf)
            radiance += applyFilter (get filter) lightRadiance
            Continue


-- Assumes we're looking towards -z.
Camera =
  { numPix     : Int
  & pos        : Position  -- pinhole position
  & halfWidth  : Float     -- sensor half-width
  & sensorDist : Float }   -- pinhole-sensor distance

-- TODO: might be better with an anonymous dependent pair for the result
def cameraRays (n:Int) (camera:Camera) : Fin n => Fin n => (Key -> Ray) =
  -- images indexed from top-left
  halfWidth = getAt #halfWidth camera
  pixHalfWidth = halfWidth / IToF n
  ys = reverse $ linspace (Fin n) (neg halfWidth) halfWidth
  xs =           linspace (Fin n) (neg halfWidth) halfWidth
  for i j. \key.
    [kx, ky] = splitKey key
    x = xs.j + randuniform (-pixHalfWidth) pixHalfWidth kx
    y = ys.i + randuniform (-pixHalfWidth) pixHalfWidth ky
    (getAt #pos camera, normalize [x, y, neg (getAt #sensorDist camera)])

def takePicture (params:Params) (scene:Scene m) (camera:Camera) : Image =
  n = getAt #numPix camera
  rays = cameraRays n camera
  rootKey = newKey 0
  image = for i j.
    pixKey = if getAt #shareSeed params
      then rootKey
      else ixkey (ixkey rootKey i) j
    sampleRayColor : Key -> Color =  \k.
      [k1, k2] = splitKey k
      trace params scene (rays.i.j k1) k2
    sampleAveraged sampleRayColor (getAt #numSamples params) pixKey
  MkImage _ _ $ image / mean (for (i,j,k). image.i.j.k)

' ### Define the scene and render it

lightColor = [0.2, 0.2, 0.2]
leftWallColor  = 1.5 .* [0.611, 0.0555, 0.062]
rightWallColor = 1.5 .* [0.117, 0.4125, 0.115]
whiteWallColor = [255.0, 239.0, 196.0] / 255.0
blockColor     = [200.0, 200.0, 255.0] / 255.0

theScene = MkScene $
    [ Light (1.0 .* yHat) 0.5 lightColor
    , PassiveObject (Wall      xHat  1.0) (Matte leftWallColor)
    , PassiveObject (Wall (neg xHat) 1.0) (Matte rightWallColor)
    , PassiveObject (Wall      yHat  1.0) (Matte whiteWallColor)
    , PassiveObject (Wall (neg yHat) 1.0) (Matte whiteWallColor)
    , PassiveObject (Wall      zHat  1.0) (Matte whiteWallColor)
    , PassiveObject (Wall (neg zHat) 1.1) (Matte whiteWallColor)
    -- , PassiveObject (Block  [ 1.0, -1.6,  1.2] [0.6, 0.8, 0.6] 0.5) (Matte blockColor)
    , PassiveObject (Sphere [-0.6, -0.7,  -0.2] 0.3) (Matte (0.7.* whiteWallColor))
    -- , PassiveObject (Sphere [ 2.0,  2.0, -2.0] 1.5) (Mirror)
    ]

defaultParams = { numSamples = 50
                , maxBounces = 10
                , shareSeed  = True }

defaultCamera = { numPix     = 50
                , pos        = 1.0 .* zHat
                , halfWidth  = 0.3
                , sensorDist = 0.2 }

-- We change to a small num pix here to reduce the compute needed for tests
params = defaultParams
camera = defaultCamera

params2 = defaultParams |> setAt #numSamples 1
%time
(MkImage _ _ image2) = takePicture params2 theScene camera

:html imshow image2
> <html output>