' ## Reimplement NGLOD - OctreeSDF
<https://github.com/nv-tlabs/nglod/blob/main/sdf-net/lib/models/OctreeSDF.py>

import plot
key = newKey 0

Height = Fin 100
Width = Fin 100
Position_t = Fin 2
Feature_t = Fin 3
Position = Position_t => Float
Feature = Feature_t => Float
Distance = Float

instance [Add a, Add b] Add (a & b)
    add = \(a, b) (c, d). ( (a + c), (b + d))
    sub = \(a, b) (c, d). ( (a - c), (b - d))
    zero = (zero, zero)

instance [VSpace a, VSpace b] VSpace (a & b)
    scaleVec = \ s (a, b) . (scaleVec s a, scaleVec s b)

def ind2NormalizedPos (idx: Fin n) : Float =
    -- requirement n>=2
    2.*(IToF $ ordinal idx) / (IToF n - 1.) - 1.

:p for i:(Fin 11). ind2NormalizedPos i

-- SDF should only accept normalized position [-1., 1.]
-- TODO-5 enforce this with type system.

def plotSdfPoint (sdf:(Position -> Distance)) (x:Fin n) (y:Fin m) : Distance =
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    sdf [x', y']

def plotSdf (sdf:(Position -> Distance)) : (Fin n)=>(Fin m)=>Distance =
    for x y. plotSdfPoint sdf x y

' ### Construct a target 2D SDF

def circleSdf (p:Position) (r:Float) : Distance =
    dist = sqrt $ sum $ for d. (sq p.d)
    max dist r

def targetSdf (p:Position) : Distance =
    circleSdf p 0.1

target : Height=>Width=>Float = plotSdf targetSdf

:html matshow target

' ### Build the OctreeSDF

Hidden_t = Fin 128
In_t = {leftout: Position_t | rightout: Feature_t}
Out_t = Fin 1
WnB : Type = (In_t=>Hidden_t=>Float & Hidden_t => Float & Hidden_t => Out_t => Float & Out_t=>Float)
-- currently only support joint decoder mode TODO-1
joint_decoder_mode = True

instance [Arbitrary a] Arbitrary (In_t=>Float)
    arb = \key.
        for ind.
            [keyl, keyr] = splitKey $ ixkey key ind
            case ind of
                {| leftout = i  |} -> arb keyl
                {| rightout = i |} -> arb keyr

' ##### the Octree part

def linearInterp [VSpace a] (x1:Float) (x2:Float) (k1:a) (k2:a) (x:Float) : a =
    --     x1   x       x2
    -- ----------------------->
    --     k1   ?       k2
    w = (x-x1) / (x2-x1)
    scaleVec (1.0 - w) k1 + scaleVec w k2

def bilinearInterp [VSpace a]
        (p1:Position) (p2:Position) (p3:Position) (p4:Position)
        (k1:a) (k2:a) (k3:a) (k4:a)
        (p:Position) : a =
    --
    --  p1, p2, p4, p3 form a square
    --  0------------(dim 1)
    --  |   p1    p3
    --  |      p
    --  |   p2    p4
    --  (dim 0)
    --
    k5 = linearInterp p1.(0@_) p2.(0@_) k1 k2 p.(0@_)
    k6 = linearInterp p3.(0@_) p4.(0@_) k3 k4 p.(0@_)
    linearInterp p1.(1@_) p3.(1@_) k5 k6 p.(1@_)

-- def trilinearInterp [VSpace a]


def InputTable (edgeLen:Int) (a:Type): Type =
    (Fin edgeLen) => (Fin edgeLen) => a

def boundBy [Ord o] (min:o) (max:o) (x:o) : o =
    x' = select (x>max) max x
    select (x<min) min x'

def queryInputTable ([h, w]:Position)
    (table: InputTable edgeLen a) : a =
    w' = boundBy 0 (edgeLen-1) (FToI w)
    h' = boundBy 0 (edgeLen-1) (FToI h)
    table.(h'@_).(w'@_)

def normalizedPos2Ind (normalizedPos:Float) (sz:Int) : Float =
    -- -1.0------------>+1.0
    -- 0.0 ------------>sz-1
    (normalizedPos + 1.0) / 2.0 * (IToF (sz-1))

def getInputTable [Arbitrary a]: InputTable edgeLen a = arb key

def badname(x:n=>m=>o=>Float) : n=>m=>o=>Float =
    for i j k.
        y = x.i.j.k
        2.0 * (y- floor y - 0.5)

def intpow2 (power:Int) : Int = %shl 1 power

-- "FeatureVolume.forward" in OctreeSDF
-- reimplementing torch.nn.Functional.grid_sample
def spatialFeatures
        (inputTable:InputTable edgeLen Feature)
        (normalizedPos:Position) : Feature =
    inputPos = for d. normalizedPos2Ind normalizedPos.d edgeLen
    p1h = floor inputPos.(0@_)
    p1w = floor inputPos.(1@_)
    p1 = [p1h, p1w]
    p2 = [p1h+1., p1w]
    p3 = [p1h, p1w+1.]
    p4 = [p1h+1., p1w+1.]
    k1 = queryInputTable p1 inputTable
    k2 = queryInputTable p2 inputTable
    k3 = queryInputTable p3 inputTable
    k4 = queryInputTable p4 inputTable
    bilinearInterp p1 p2 p3 p4 k1 k2 k3 k4 inputPos

inputTable4 : InputTable 16 Feature = badname $ getInputTable

edgeLenTest = intpow2 4
inputTableTest : InputTable edgeLenTest Feature = badname $ getInputTable
:t inputTableTest
:t inputTable4

%time
test_im : (Fin 10) => (Fin 10) => Color = for x y.
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    spatialFeatures inputTable4 [x', y']

-- -- should be continuous
-- :html imshow test_im
-- :p head test_im

' output = grid_sample(input, grid) is a function used in the original OctreeSDF <https://www.programmersought.com/article/10374524300/>
<https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.grid_sample> here only the 4D input grid_sample is implemented

' ##### the neural net part

def mlp (v1: In_t=>Float) ((w1,b1,w2,b2): WnB) : Out_t=>Float =
    relu = \x.(max x 0.)
    v2 = map relu $ (transpose w1) **. v1 + b1
    (transpose w2) **. v2 + b2

def l2losspoint (sdf: Position->Distance) (point: (Height&Width)) : Float =
    (i, j) = point
    pred = plotSdfPoint sdf i j
    sq $ pred - target.i.j

def l2loss (sdf: Position->Distance) : Float =
    pred = plotSdf sdf
    diff2 = sq (pred-target)
    mean for i. mean diff2.i

' ##### Combine Octree and nn

def concatTable (left: a=>v) (right: b=>v) : ({leftout:a | rightout:b }=>v) =
  for idx. case idx of
    {| leftout = i  |} -> left.i
    {| rightout = i |} -> right.i

def octreeSDF
    (inputTable: InputTable edgeLen Feature)
    (wnb: WnB) (x: Position) : Distance =
    -- z:Feature = yieldState zero \z_ref.
        -- yieldAccum TODO-4
    --    for i:(Fin lod).
    --        z_cur = get z_ref
    --        z_ref := z_cur + spatialFeatures lod x
    z : Feature = spatialFeatures inputTable x
    input = concatTable x z
    out = mlp input wnb
    out.(0@_)

' ### Training

lr : Float = 0.01
iters : Int = 10000
minibatch_sz : Int = 5

-- edgeLen = 2^lod = 2^7 = 128
%time
inputTable : InputTable 128 Feature = badname $ getInputTable

%time
wnb_sgd:WnB = yieldState (arb key) \wnb_ref.
    for i:(Fin iters).
        keyi = ixkey key i
        wnb = get wnb_ref
        samples = for k:(Fin minibatch_sz). arb $ ixkey keyi k
        loss = \w.
            curr_sdf = \x. octreeSDF inputTable w x
            mean $ for k. l2losspoint curr_sdf samples.k
        gradient = (grad loss) wnb
        wnb_ref := wnb - scaleVec lr gradient

final_sdf = \x. octreeSDF inputTable wnb_sgd x
final_loss = l2loss final_sdf
:p final_loss

:html matshow target

im : Height=>Width=>Float = plotSdf final_sdf

:html matshow im

-- TODO-2 raymarch to render SDF

' ### Render with raymarching

Direction = Position

def raymarch 
	(pos:Position) (dir: Direction) 
	(sdf:Position->Distance) : Color = 
    finalraylen = yieldState 0.1 \raylen.
        while \().
            rayPos = pos + get raylen .* dir
            d = sdf rayPos
            raylen := get raylen + d*0.9
            d > 0.01 && get raylen < 1000.
    if finalraylen > 1000. then zero else 
        abs $ (grad sdf) (pos + finalraylen .* dir)
-- not sure how `abs` works e.g. [(-1), (-2), (-3)] > zero

im2:Height=>Width=>Color = for x y.
	l = ind2NormalizedPos x
	v = ind2NormalizedPos y
	raymarch [l*10., v*10., -4.] [0., 0., 1.] final_sdf

:html imshow im2

