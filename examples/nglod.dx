' ## Reimplement NGLOD - OctreeSDF
<https://github.com/nv-tlabs/nglod/blob/main/sdf-net/lib/models/OctreeSDF.py>

import plot
key = newKey 0

Depth = Fin 100
Height = Fin 100
Width = Fin 100
Position_t = Fin 3
Feature_t = Fin 3
Position = Position_t => Float
Feature = Feature_t => Float
Distance = Float

instance [Add a, Add b] Add (a & b)
    add = \(a, b) (c, d). ( (a + c), (b + d))
    sub = \(a, b) (c, d). ( (a - c), (b - d))
    zero = (zero, zero)

instance [VSpace a, VSpace b] VSpace (a & b)
    scaleVec = \ s (a, b) . (scaleVec s a, scaleVec s b)

def ind2NormalizedPos (idx: Fin n) : Float =
    -- requirement n>=2
    2.*(IToF $ ordinal idx) / (IToF n - 1.) - 1.

:p for i:(Fin 11). ind2NormalizedPos i

-- SDF should only accept normalized position [-1., 1.]
-- TODO-5 enforce this with type system.

def plotSdfPoint
	(sdf:(Position -> Distance))
	(x:Fin n) (y:Fin m) (z:Fin o): Distance =
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    z' = ind2NormalizedPos z
    sdf [x', y', z']

def plotSdf
	(sdf:(Position -> Distance))
	: (Fin n)=>(Fin m)=>(Fin o)=>Distance =
    for x y z. plotSdfPoint sdf x y z

' ### Construct a target 3D SDF

def circleSdf (p:Position) (r:Float) : Distance =
    dist = sqrt $ sum $ for d. (sq p.d)
    max dist r

def targetSdf (p:Position) : Distance =
    circleSdf p 0.1

target : Depth=>Height=>Width=>Float = plotSdf targetSdf

:html matshow target.(0@Depth)

:html matshow target.(5@Depth)

' ### Build the OctreeSDF

Hidden_t = Fin 128
In_t = {leftout: Position_t | rightout: Feature_t}
Out_t = Fin 1
WnB : Type = (In_t=>Hidden_t=>Float & Hidden_t => Float & Hidden_t => Out_t => Float & Out_t=>Float)
-- currently only support joint decoder mode TODO-1
joint_decoder_mode = True

instance [Arbitrary a] Arbitrary (In_t=>Float)
    arb = \key.
        for ind.
            [keyl, keyr] = splitKey $ ixkey key ind
            case ind of
                {| leftout = i  |} -> arb keyl
                {| rightout = i |} -> arb keyr

' ##### the Octree part

def Vec (n:Int) : Type = (Fin n)=>Float

def linearInterp [VSpace a] (x1:Float) (x2:Float) (k1:a) (k2:a) (x:Float) : a =
    --     x1   x       x2
    -- ----------------------->
    --     k1   ?       k2
    w = (x-x1) / (x2-x1)
    scaleVec (1.0 - w) k1 + scaleVec w k2

def bilinearInterp [VSpace a]
	(p1:Vec 2) (p2:Vec 2) (p3:Vec 2) (p4:Vec 2)
	(k1:a) (k2:a) (k3:a) (k4:a)
	(p:Vec 2) : a =
    --
    --  p1, p2, p4, p3 form a square
    --  0------------(dim 1)
    --  |   p1    p3
    --  |      p
    --  |   p2    p4
    --  (dim 0)
    --
    k5 = linearInterp p1.(0@_) p2.(0@_) k1 k2 p.(0@_)
    k6 = linearInterp p3.(0@_) p4.(0@_) k3 k4 p.(0@_)
    linearInterp p1.(1@_) p3.(1@_) k5 k6 p.(1@_)

def trilinearInterp [VSpace a]
	(p1:Vec 3) (p2:Vec 3) (p3:Vec 3) (p4:Vec 3)
	(p5:Vec 3) (p6:Vec 3) (p7:Vec 3) (p8:Vec 3)
	(k1:a) (k2:a) (k3:a) (k4:a)
	(k5:a) (k6:a) (k7:a) (k8:a)
	(p:Vec 3) : a =
    -- n@(dim 0)   0------------(dim 2)
    --             |   p1    p3
    --             |      p
    --             |   p2    p4
    --             (dim 1)
    -- n+1@(dim 0) 0------------(dim 2)
    --             |   p5    p7
    --             |      p
    --             |   p6    p8
    --             (dim 1)
    dropHead : Vec 3 -> Vec 2 = \v3. [v3.(1@_), v3.(2@_)]
    k9  = bilinearInterp (dropHead p1) (dropHead p2) (dropHead p3) (dropHead p4) k1 k2 k3 k4 (dropHead p)
    k10 = bilinearInterp (dropHead p5) (dropHead p6) (dropHead p7) (dropHead p8) k5 k6 k7 k8 (dropHead p)
    linearInterp p1.(0@_) p5.(0@_) k9 k10 p.(0@_)


def InputTable (edgeLen:Int) (a:Type): Type =
    (Fin edgeLen) => (Fin edgeLen) => (Fin edgeLen) => a

def boundBy [Ord o] (min:o) (max:o) (x:o) : o =
    x' = select (x>max) max x
    select (x<min) min x'

def queryInputTable (table: InputTable edgeLen a) ([d, h, w]:Position) : a =
    d' = boundBy 0 (edgeLen-1) (FToI d)
    h' = boundBy 0 (edgeLen-1) (FToI h)
    w' = boundBy 0 (edgeLen-1) (FToI w)
    table.(d'@_).(h'@_).(w'@_)

def normalizedPos2Ind (normalizedPos:Float) (sz:Int) : Float =
    -- -1.0------------>+1.0
    -- 0.0 ------------>sz-1
    (normalizedPos + 1.0) / 2.0 * (IToF (sz-1))

def getInputTable [Arbitrary a]: InputTable edgeLen a = arb key

-- TODO
def badname(x:n=>m=>o=>p=>Float) : n=>m=>o=>p=>Float =
    for i j k l.
        y = x.i.j.k.l
        2.0 * (y- floor y - 0.5)

def intpow2 (power:Int) : Int = %shl 1 power

-- "FeatureVolume.forward" in OctreeSDF
-- reimplementing torch.nn.Functional.grid_sample
def spatialFeatures
        (inputTable:InputTable edgeLen Feature)
        (normalizedPos:Position) : Feature =
    inputPos = for d. normalizedPos2Ind normalizedPos.d edgeLen
    [p1d, p1h, p1w] = map floor inputPos
    p1 = [p1d, p1h, p1w]
    p2 = [p1d, p1h+1., p1w]
    p3 = [p1d, p1h, p1w+1.]
    p4 = [p1d, p1h+1., p1w+1.]
    p5 = [p1d+1., p1h, p1w]
    p6 = [p1d+1., p1h+1., p1w]
    p7 = [p1d+1., p1h, p1w+1.]
    p8 = [p1d+1., p1h+1., p1w+1.]
    [k1, k2, k3, k4, k5, k6, k7, k8] = map (queryInputTable inputTable) [p1, p2, p3, p4, p5, p6, p7, p8]
    trilinearInterp p1 p2 p3 p4 p5 p6 p7 p8 k1 k2 k3 k4 k5 k6 k7 k8 inputPos

inputTable4 : InputTable 16 Feature = badname $ getInputTable

edgeLenTest = intpow2 4
inputTableTest : InputTable edgeLenTest Feature = badname $ getInputTable
:t inputTableTest
:t inputTable4

%time
test_im : (Fin 10) => (Fin 10) => (Fin 10) => Color = for x y z.
    x' = ind2NormalizedPos x
    y' = ind2NormalizedPos y
    z' = ind2NormalizedPos z
    spatialFeatures inputTable4 [x', y', z']

-- -- should be continuous
:html imshow test_im.(5@(Fin 10))

' output = grid_sample(input, grid) is a function used in the original OctreeSDF <https://www.programmersought.com/article/10374524300/>
<https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.grid_sample> here only the 4D input grid_sample is implemented

' ##### the neural net part

def mlp (v1: In_t=>Float) ((w1,b1,w2,b2): WnB) : Out_t=>Float =
    relu = \x.(max x 0.)
    v2 = map relu $ (transpose w1) **. v1 + b1
    (transpose w2) **. v2 + b2

def l2losspoint (sdf: Position->Distance) (point: (Depth&Height&Width)) : Float =
    (x, y, z) = point
    pred = plotSdfPoint sdf x y z
    sq $ pred - target.x.y.z

def l2loss (sdf: Position->Distance) : Float =
    pred = plotSdf sdf
    diff2 = sq (pred-target)
    mean for i. mean for j. mean diff2.i.j

' ##### Combine Octree and nn

def concatTable (left: a=>v) (right: b=>v) : ({leftout:a | rightout:b }=>v) =
  for idx. case idx of
    {| leftout = i  |} -> left.i
    {| rightout = i |} -> right.i

def octreeSDF
    (inputTable: InputTable edgeLen Feature)
    (wnb: WnB) (x: Position) : Distance =
    -- z:Feature = yieldState zero \z_ref.
        -- yieldAccum TODO-4
    --    for i:(Fin lod).
    --        z_cur = get z_ref
    --        z_ref := z_cur + spatialFeatures lod x
    z : Feature = spatialFeatures inputTable x
    input = concatTable x z
    out = mlp input wnb
    out.(0@_)

' ### Training

lr : Float = 0.01
iters : Int = 10000
minibatch_sz : Int = 5

-- edgeLen = 2^lod = 2^7 = 128
%time
inputTable : InputTable 128 Feature = badname $ getInputTable

%time
wnb_sgd:WnB = yieldState (arb key) \wnb_ref.
    for i:(Fin iters).
        keyi = ixkey key i
        wnb = get wnb_ref
        samples = for k:(Fin minibatch_sz). arb $ ixkey keyi k
        loss = \w.
            curr_sdf = \x. octreeSDF inputTable w x
            mean $ for k. l2losspoint curr_sdf samples.k
        gradient = (grad loss) wnb
        wnb_ref := wnb - scaleVec lr gradient

final_sdf = \x. octreeSDF inputTable wnb_sgd x
final_loss = l2loss final_sdf
:p final_loss

:html matshow target.(5@Depth)

im : Depth=>Height=>Width=>Float = plotSdf final_sdf
:html matshow im.(5@Depth)


-- TODO-2 raymarch to render SDF

-- ' ### Render with raymarching
-- 
-- Direction = Position
-- 
-- def raymarch 
-- 	(pos:Position) (dir: Direction) 
-- 	(sdf:Position->Distance) : Color = 
--     finalraylen = yieldState 0.1 \raylen.
--         while \().
--             rayPos = pos + get raylen .* dir
--             d = sdf rayPos
--             raylen := get raylen + d*0.9
--             d > 0.01 && get raylen < 1000.
--     if finalraylen > 1000. then zero else 
--         abs $ (grad sdf) (pos + finalraylen .* dir)
-- -- not sure how `abs` works e.g. [(-1), (-2), (-3)] > zero
-- 
-- im2:Depth=>Height=>Width=>Color = for x y z.
--     x' = ind2NormalizedPos x
--     y' = ind2NormalizedPos y
--     z' = ind2NormalizedPos z
--     raymarch [x'*10., y'*10., z'*10.] [0., 0., 1.] final_sdf
-- 
-- :html imshow $ sliceVolume (5@Depth) im2
-- 
-- :p head im2
