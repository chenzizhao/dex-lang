' # Cholesky Factorization
https://en.wikipedia.org/wiki/Cholesky_decomposition

import linalg

' ## Cholesky Algorithm

def lowerTriMat (ref:Ref h (LowerTriMat a b)) (i:a) (j:(..i)) : Ref h b =
    d = %indexRef ref i
    d!j

def cast (d:a) : m = (ordinal d)@m

def chol [Eq n] (x:n=>n=>Float) : LowerTriMat n Float =
  yieldState zero \buf.
    mat = lowerTriMat buf
    for i:n. for j':(..i).
      j = %inject j'
      row  = for k:(..<j). get $ mat i (cast k)
      row' = for k:(..<j). get $ mat j (cast k)
      a = x.i.j - vdot row row'
      if (ordinal i)==(ordinal j)
        then
          mat i j' := sqrt a
        else
          b = get $ mat j (cast j')
          mat i j' := a / b

' ## PSD solver based on Cholesky decomposition

def trisolveL (mat:n=>n=>Float) (b:n=>Float) : n=>Float =
  yieldState zero \buf. for i.
    row   = for j:(..<i). mat.i.(%inject j)
    xPrev = for j:(..<i). get (buf!%inject j)
    buf!i := (b.i - vdot row xPrev) / mat.i.i

def trisolveU (mat:n=>n=>Float) (b:n=>Float) : n=>Float =
  yieldState zero \buf. rof i.
    row   = for j:(i..). mat.i.%inject(j)
    xPrev = for j:(i..). get (buf!%inject j)
    buf!i := (b.i - vdot row xPrev) / mat.i.i

def psdsolve [Eq n] (mat:n=>n=>Float) (b:n=>Float) : n=>Float =
  l = chol mat
  trisolveU (transpose l) $  trisolveL l b

' Test

N = Fin 4
[k1, k2] = splitKey $ newKey 0

psd : N=>N=>Float =
  a = for i:N j:N. randn $ ixkey2 k1 i j
  x = a ** transpose a
  x + eye

l = chol psd

:p l
> [ [2.021765, 0., 0., 0.]
> , [-1.795019, 1.990174, 0., 0.]
> , [-0.897886, 0.186757, 1.980266, 0.]
> , [1.445752, -0.296448, 0.724586, 2.230807] ]

psdReconstructed = l ** transpose l

:p sum for (i, j). sq (psd.i.j - psdReconstructed.i.j)
> 0.

vec : N=>Float = arb k2

:p (vec, psd **. psdsolve psd vec)
> ( [1.211277, 0.23285, -0.741911, 0.883351]
> , [1.211277, 0.23285, -0.741911, 0.883351] )
